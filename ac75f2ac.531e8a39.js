(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{213:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return p})),n.d(t,"rightToc",(function(){return u})),n.d(t,"default",(function(){return f}));var r=n(1),a=n(9),o=(n(0),n(261)),i=n(262),c=n(272),l=(n(274),n(276),n(273),n(271)),s={id:"TouchGFXHALDevelopmentScenariosFMC",title:"FMC and SPI"},p={id:"Development/TouchGFXHALDevelopment/scenarios/TouchGFXHALDevelopmentScenariosFMC",title:"FMC and SPI",description:"import Figure from '@site/components/Figure';\r",source:"@site/docs\\Development\\TouchGFXHALDevelopment\\scenarios\\FMC.mdx",permalink:"/docs/Development/TouchGFXHALDevelopment/scenarios/TouchGFXHALDevelopmentScenariosFMC",sidebar:"docs",previous:{title:"LTDC/Parallel RGB",permalink:"/docs/Development/TouchGFXHALDevelopment/TouchGFXHALDevelopmentScenarios"},next:{title:"Framebuffer Strategies",permalink:"/docs/Development/TouchGFXHALDevelopment/scenarios/TouchGFXHALDevelopmentScenariosFrameBuffer"}},u=[{value:"Transferring the framebuffer",id:"transferring-the-framebuffer",children:[]},{value:"Returning from HAL::flushFrameBuffer()",id:"returning-from-halflushframebuffer",children:[]},{value:"TouchGFX Driver / Tearing Effect Signal",id:"touchgfx-driver--tearing-effect-signal",children:[]},{value:"Conclusion",id:"conclusion",children:[]}],h={rightToc:u},d="wrapper";function f(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(o.b)(d,Object(r.a)({},h,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"The following scenario shows, generally, the steps involved in writing a TouchGFX driver when selecting ",Object(o.b)("em",{parentName:"p"},"Custom")," display interface in the TouchGFX generator using an LCD connected to either an FMC or through SPI. "),Object(o.b)(l.a,{mdxType:"FurtherReading"},"the STM32L496-DISCO Application template available from the designer uses FMC and can be inspected for inspiration on how to implement a TouchGFX display driver."),Object(o.b)("p",null,"The process of writing a TouchGFX display driver for MCUs without embedded display controllers over FMC or SPI\xbd is identical. The scenario described in this section uses an ST7789H2 LCD Controller to exemplify. "),Object(o.b)("p",null,"Once FMC or SPI is configured according to board specifications in CubeMX the TouchGFX Generator can be used to generate a HAL, selecting the ",Object(o.b)("em",{parentName:"p"},"Custom")," display interface, which allows developers to write custom code to transfer the updated parts of the application framebuffer to a connected display. "),Object(o.b)("p",null,"The figure below shows a TouchGFX Generator configuration with ",Object(o.b)("em",{parentName:"p"},"Custom")," Display Interface selected. This instructs the TouchGFX Generator that the developer would like to configure and transfer pixels from the framebuffer memory to the display manually and generates the handles to accomplish this. "),Object(o.b)(c.a,{mdxType:"Note"},"The driver code shown in this section for the ST7789H2 would have been developed during the Board Bringup phase and, once working, can more or less be copied to the HAL class generated by the TouchGFX Generator.",Object(o.b)("p",null,"The driver must be able to transfer pixels to the display, and to control the memory writing position of the display. Check its datasheet to find appropriate commands, outlined below, and further details.")),Object(o.b)(i.a,{imageSource:"/img/Development/TouchGFXHALDevelopment/scenarios/custom_interface.png",caption:"TouchGFX Generator Configuration",noShadow:!1,mdxType:"Figure"}),Object(o.b)("p",null,"Generally, for displays with embedded GRAM such as 8080 or SPI displays, the driver works as follows:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},'Based on the area of the framebuffer to be redrawn, move the "display cursor" and "active window" to a place in GRAM that matches this area.'),Object(o.b)("li",{parentName:"ol"},"Prepare to write incoming pixel data to GRAM."),Object(o.b)("li",{parentName:"ol"},"Send pixel data. ")),Object(o.b)("h2",{id:"transferring-the-framebuffer"},"Transferring the framebuffer"),Object(o.b)("p",null,"When an area of the framebuffer has been updated, the TouchGFX Engine calls ",Object(o.b)("inlineCode",{parentName:"p"},"HAL::flushFrameBuffer(Rect r)"),'. This function can be overridden when developers must implement a driver for a "Custom" display interface.'),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-cpp"}),"void  TouchGFXHAL::flushFrameBuffer(const Rect& rect)\n{    \n    /* Set Cursor */\n    __ST7789H2_SetDisplayWindow(rect.x, rect.y, rect.width, rect.height);\n\n    /* Prepare to write to LCD RAM */\n    ST7789H2_WriteReg(ST7789H2_WRITE_RAM, (uint8_t*)NULL, 0);\n\n    /* Send Pixels */\n    this->copyFrameBufferBlockToLCD(rect);\n}\n")),Object(o.b)("p",null,"The following function ",Object(o.b)("inlineCode",{parentName:"p"},"__ST7789H2_SetDisplayWindow")," sets the ",Object(o.b)("inlineCode",{parentName:"p"},"x")," and ",Object(o.b)("inlineCode",{parentName:"p"},"y"),' coordinates for the virtual "cursor" in GRAM by writing to specific registers, which is usual for displays using GRAM.'),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-c"}),'extern "C"\nvoid __ST7789H2_SetDisplayWindow(uint16_t Xpos, uint16_t Ypos, uint16_t Width, uint16_t Height)\n{\n    uint8_t   parameter[4];\n\n    /* CASET: Column Addrses Set */\n    parameter[0] = 0x00;\n    parameter[1] = Xpos;\n    parameter[2] = 0x00;\n    parameter[3] = Xpos + Width - 1;\n    ST7789H2_WriteReg(ST7789H2_CASET, parameter, 4);\n\n    /* RASET: Row Addrses Set */\n    parameter[0] = 0x00;\n    parameter[1] = Ypos;\n    parameter[2] = 0x00;\n    parameter[3] = Ypos + Height - 1;\n    ST7789H2_WriteReg(ST7789H2_RASET, parameter, 4);\n}\n')),Object(o.b)("p",null,"The following function ",Object(o.b)("inlineCode",{parentName:"p"},"TouchGFXHAL::copyFrameBufferBlockToLCD")," is a private function that sends one line of the updated area (",Object(o.b)("inlineCode",{parentName:"p"},"Rect"),") at a time, ensuring to progress the framebuffer pointer accordingly. "),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-cpp"}),"void TouchGFXHAL::copyFrameBufferBlockToLCD(const Rect rect)\n{\n    __IO uint16_t* ptr;\n    uint32_t height;\n\n    // This can be accelerated using regular DMA hardware\n    for (height = 0; height < rect.height ; height++)\n    {\n        ptr = getClientFrameBuffer() + rect.x + (height + rect.y)  * BSP_LCD_GetXSize();\n        LCD_IO_WriteMultipleData((uint16_t*)ptr, rect.width);\n    }\n}\n")),Object(o.b)("p",null,"Instead of advancing ",Object(o.b)("inlineCode",{parentName:"p"},"ptr")," manually, the TouchGFX Generator will generate a function ",Object(o.b)("inlineCode",{parentName:"p"},"advanceFrameBufferToRect")," that advances ",Object(o.b)("inlineCode",{parentName:"p"},"ptr")," according to the position of ",Object(o.b)("inlineCode",{parentName:"p"},"Rect")," in the framebuffer.  "),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-cpp"}),"inline uint8_t* TouchGFXGeneratedHAL::advanceFrameBufferToRect(uint8_t* fbPtr, const touchgfx::Rect& rect) const\n{\n    //       Advance vertically                   Advance horizontally\n    fbPtr += rect.y * lcd().framebufferStride() + rect.x * 2;\n    return fbPtr;\n}\n")),Object(o.b)("h2",{id:"returning-from-halflushframebuffer"},"Returning from HAL::flushFrameBuffer()"),Object(o.b)("p",null,"Once the function returns TouchGFX Engine continues to draw the rest of the frame. If developers wish to use DMA to transfer pixels to the display, they must ensure that ",Object(o.b)("inlineCode",{parentName:"p"},"HAL::flushFrameBuffer(Rect& rect)")," does not return immediatly by e.g. waiting on a semaphore signaled by a ",Object(o.b)("em",{parentName:"p"},"DMA Completed")," interrupt. "),Object(o.b)("p",null,"The following pseudo-code example shows an example of how ",Object(o.b)("inlineCode",{parentName:"p"},"HAL::flushFrameBuffer()")," could be structured in case DMA is used. The code uses a FreeRTOS semaphore ",Object(o.b)("inlineCode",{parentName:"p"},"screen_frame_buffer_sem"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-cpp"}),"void TouchGFXHAL::flushFrameBuffer(const touchgfx::Rect& rect)\n{\n    uint16_t* fb = HAL::lockFrameBuffer(); \n  \n    //Prepare display\n    prepare();\n  \n    //Try to take a display semaphore - Always free at this point\n    xSemaphoreTake(screen_frame_buffer_sem, portMAX_DELAY);\n       \n    //Set up DMA\n    screenDMAEnable();\n            \n    // Wait for the DMA transfer to complete\n    xSemaphoreTake(screen_frame_buffer_sem, portMAX_DELAY);\n           \n    //Unlock framebuffer and give semaphore back\n    HAL::unlockFrameBuffer();\n    xSemaphoreGive(screen_frame_buffer_sem);       \n}\n")),Object(o.b)("h2",{id:"touchgfx-driver--tearing-effect-signal"},"TouchGFX Driver / Tearing Effect Signal"),Object(o.b)("p",null,'As can be seen in TouchGFX Generator configuration above, the "Application Tick Source" is also set to "Custom", which is general for MCUs without embedded TFT Controllers.'),Object(o.b)("p",null,"As described in the Abstraction Layer Architecture section, the TouchGFX Engine main loop is unblocked by calling ",Object(o.b)("inlineCode",{parentName:"p"},"OSWrappers::signalVSync()"),", usually at the time when a display signals."),Object(o.b)("p",null,'For displays with a serial or 8080 display interface, the embedded display controller typically raises a periodic Tearing Effect (TE) signal that can be connected to a GPIO on the MCU. In this case, the MCU is usually configured to raise an interrupt when the GPIO is signalled. This "Tearing Effect" interrupt will then unblock the TouchGFX Engine Main loop to render the next frame. Remember to configure the GPIO to input and enable the external interrupt for the pin in CubeMX.'),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-cpp"}),'extern "C"\nvoid TE_Handler(void)\n{\n    ...\n    /* Unblock TouchGFX Engine Main Loop to render next frame */\n    OSWrappers::signalVSync();\n    ...\n}\n\n')),Object(o.b)("h2",{id:"conclusion"},"Conclusion"),Object(o.b)("p",null,"Selecting ",Object(o.b)("em",{parentName:"p"},"Custom")," Display Interface throgh the TouchGFX Generator is an expression of a developers intent to write code to transfer pixels from an application frame buffer to a display, manually."),Object(o.b)("p",null,"The TouchGFX Generator will generate a function ",Object(o.b)("inlineCode",{parentName:"p"},"TouchGFXHAL::flushFrameBuffer(Rect& rect)")," that is called automatically by TouchGFX after rendering an area of the framebuffer that developers can use to transfer affected pixels to a display, SPI, FMC or otherwise."),Object(o.b)("p",null,"Selecting a ",Object(o.b)("em",{parentName:"p"},"custom")," display interface also requires developers to implement a custom TouchGFX Application Tick driver that signals ",Object(o.b)("inlineCode",{parentName:"p"},"OSWrappers::signalVSync()")," to unblock the TouchGFX Engine Main loop. Usually, displays used along with MCUS that have no TFT Controllers can provide a ",Object(o.b)("em",{parentName:"p"},"Tearing Effect")," signal that is connected to the MCU.  "))}f.isMDXComponent=!0},272:function(e,t,n){"use strict";var r=n(5),a=n(0),o=n.n(a),i=n(265),c=o.a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},o.a.createElement("path",{"fill-rule":"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})),l=function(e){function t(){return e.apply(this,arguments)||this}return Object(r.a)(t,e),t.prototype.render=function(){return o.a.createElement(i.a,{color:"var(--highlight-color-note)",header:"Note",type:"note",icon:c},this.props.children)},t}(a.Component);t.a=l},276:function(e,t,n){"use strict";var r=n(5),a=n(0),o=n.n(a),i=n(265),c=o.a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},o.a.createElement("path",{"fill-rule":"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})),l=function(e){function t(){return e.apply(this,arguments)||this}return Object(r.a)(t,e),t.prototype.render=function(){return o.a.createElement(i.a,{color:"var(--highlight-color-try)",header:"Things to try",type:"try",icon:c},this.props.children)},t}(a.Component);t.a=l}}]);