(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{199:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"metadata",(function(){return d})),n.d(t,"rightToc",(function(){return p})),n.d(t,"default",(function(){return b}));var i=n(1),a=n(9),o=(n(0),n(209)),r=n(220),s=n(210),c=n(214),l={id:"GraphicsEngine",title:"Graphics Engine"},d={id:"BasicConcepts/GraphicsEngine",title:"Graphics Engine",description:"import Link from '@docusaurus/Link';",source:"@site/docs\\BasicConcepts\\GraphicsEngine.mdx",permalink:"/docs/BasicConcepts/GraphicsEngine",sidebar:"docs",previous:{title:"Embedded Graphics Primer",permalink:"/docs/BasicConcepts/EmbeddedGraphics"},next:{title:"Framebuffer",permalink:"/docs/BasicConcepts/Framebuffer"}},p=[{value:"Scene model",id:"scene-model",children:[{value:"A tree of widgets",id:"a-tree-of-widgets",children:[]}]},{value:"Drawing API",id:"drawing-api",children:[]},{value:"Main Loop",id:"main-loop",children:[{value:"Tasks",id:"tasks",children:[]}]},{value:"Platform adaptibility",id:"platform-adaptibility",children:[]},{value:"Number of pixels...",id:"number-of-pixels",children:[]},{value:"STM32 microcontrollers",id:"stm32-microcontrollers",children:[]},{value:"Rendering cycle",id:"rendering-cycle",children:[]}],h={rightToc:p},m="wrapper";function b(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(o.b)(m,Object(i.a)({},h,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"TouchGFX graphics engine's main responsibility is drawing graphics on the display of an embedded device."),Object(o.b)("p",null,"This section will give an overview of what kind of graphics engine TouchGFX is and provide some background on why it is this way."),Object(o.b)("h2",{id:"scene-model"},"Scene model"),Object(o.b)("p",null,"Graphics engines can be divided into two main categories."),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"Immediate mode graphics engines")," provide an API that enables an application to directly draw things to the display. It is the responsibility of the application to ensure that the correct drawing operations are invoked at the right time."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"Retained mode graphics engines")," let the user manipulate an abstract model of the components being displayed. The engine takes care of translating this component model into the correct graphics drawing operations at the right times.")),Object(o.b)("p",null,"TouchGFX follows the retained mode graphics principles. In short this means that TouchGFX provides a model that can be manipulated by the user and TouchGFX then takes care of translating from this model into an optimized set of rendering method calls."),Object(o.b)(c.a,{imageSource:"/img/BasicConcepts/retained_mode_graphics2.svg",caption:"Retained mode graphics",noShadow:"true",width:480,mdxType:"Figure"}),Object(o.b)("p",null,"The benefits of TouchGFX being retained are many. Primary ones are"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"Ease of use:")," A retained graphics engine is easy to use. The user adresses the configuration of components on screen, by invoking methods on the internal model and does not think in terms of actual drawing operations."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"Performance:")," TouchGFX analyses the scene model and optimizes the drawing calls needed to realize the model on screen."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"State management:")," TouchGFX keeps track of which part of the scene model is active. This in turn makes it easier for the user to optimize the scene model contents.")),Object(o.b)("p",null,"The main drawback of TouchGFX adhering to the retained mode graphics scheme is"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"Memory consumption")," representing the scene model takes up some memory. ")),Object(o.b)("p",null,"TouchGFX reaches its performance levels, typically rendering 60 frames per second, by analyzing the scene model and optimizing the corresponding rendering done.\nGreat effort has gone into reducing the amount of memory used by the scene model of TouchGFX. In typical applications the amount of memory for this model is well below one kilobyte."),Object(o.b)("h3",{id:"a-tree-of-widgets"},"A tree of widgets"),Object(o.b)("p",null,"The scene model consists of components. "),Object(o.b)(c.a,{imageSource:"/img/BasicConcepts/scene_model.svg",caption:"A tree of widgets",noShadow:"true",width:280,mdxType:"Figure"}),Object(o.b)("p",null,"Each of the components in the model has exactly one associated parent component.\nThe parent component itself is also part of the scene model. Such a model is widely referred to as a ",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Tree_(data_structure)"}),"tree"),". "),Object(o.b)("p",null,"We will often refer to a component as a UI component or a widget. "),Object(o.b)("p",null,"Updating the displayed graphics is done by manipulating the widgets in the scene model."),Object(o.b)("h2",{id:"drawing-api"},"Drawing API"),Object(o.b)("p",null,"Ultimately, when rendering the scene model, TouchGFX will utilize its drawing API. This drawing API has methods for drawing graphics primitives, such as boxes, images, lines, polygons, textured triangles, ..."),Object(o.b)("p",null,"One can utilize these same drawing methods when extending the scene model with new types of widgets."),Object(o.b)("h2",{id:"main-loop"},"Main Loop"),Object(o.b)("p",null,"The workings of many game engines, graphics engines and in particular TouchGFX can be thought of as an infinite loop. "),Object(o.b)("p",null,"Within the main loop of TouchGFX there are three main activities"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"Collect events"),"\nCollect events from the touch screen, presses of physical buttons, messages from backend system, ..."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"Update scene model"),"\nReact to the collected events, updating the positions, animations, colors, images, ... of the model"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"Render scene model"),"\nRedraw the parts of the model that has been updated")),Object(o.b)("p",null,"In pseudocode (not at all like the actual code found within the engine) the main loop is"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-cpp"}),"while( true )\n{\n    collect();\n    update();\n    render();\n}\n")),Object(o.b)("h3",{id:"tasks"},"Tasks"),Object(o.b)("p",null,"If an operating system is at hand, TouchGFX and in particular the main loop is intended to be run as a separate task.\nThis makes it easy for the embedded system to do other work, for instance control a washing machine, in a separate task as well.\nThe two tasks can communicate via messages, in order to update the GUI with values from the rest of the system, and to send messages from the UI to the system."),Object(o.b)("p",null,"If an operating system is not present, the methods of the main loop of TouchGFX should be intertwined with the rest of the code of the system."),Object(o.b)("p",null,"TouchGFX is optimized for CPU friendliness."),Object(o.b)("p",null,"See more in ",Object(o.b)("strong",{parentName:"p"},"Operating System section TODO ")),Object(o.b)("h2",{id:"platform-adaptibility"},"Platform adaptibility"),Object(o.b)("p",null,"As TouchGFX is designed for running on any STM32 embedded setup the above phases can be customized."),Object(o.b)("p",null,"Events -> operating system"),Object(o.b)("p",null,"Drawing a box -> hardware"),Object(o.b)("p",null,"Transfer to display"),Object(o.b)("h2",{id:"number-of-pixels"},"Number of pixels..."),Object(o.b)("h2",{id:"stm32-microcontrollers"},"STM32 microcontrollers"),Object(o.b)("p",null,"Performance.\nPrerender is better than render."),Object(o.b)("h2",{id:"rendering-cycle"},"Rendering cycle"),Object(o.b)("p",null,"wait, events, update, render"),Object(o.b)("p",null,"This means that TouchGFX' primary concerns are"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Updating the contents of the display at 60Hz given the constraints of a STM32 microcontroller"),Object(o.b)("li",{parentName:"ul"},"Finding the right balance between quality and speed"),Object(o.b)("li",{parentName:"ul"},"Utilizing hardware to maximize availability of MCU"),Object(o.b)("li",{parentName:"ul"},"Ensuring that no ")),Object(o.b)(s.a,{mdxType:"FurtherReading"},Object(o.b)("li",null,"See ",Object(o.b)(r.a,{to:"https://www.st.com/en/microcontrollers-microprocessors/stm32-32-bit-arm-cortex-mcus.html",mdxType:"Link"},"STM32 32-bit Arm Cortex MCUs")," for available STM32 microcontrollers.")))}b.isMDXComponent=!0},210:function(e,t,n){"use strict";var i=n(5),a=n(0),o=n.n(a),r=n(208),s=o.a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},o.a.createElement("path",{"fill-rule":"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})),c=function(e){function t(){return e.apply(this,arguments)||this}return Object(i.a)(t,e),t.prototype.render=function(){return o.a.createElement(r.a,{color:"var(--highlight-color-further-reading)",header:"Further reading",type:"further-reading",icon:s},this.props.children)},t}(a.Component);t.a=c}}]);