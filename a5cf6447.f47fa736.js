(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{192:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return b})),n.d(t,"metadata",(function(){return g})),n.d(t,"rightToc",(function(){return x})),n.d(t,"default",(function(){return f}));var a=n(1),i=n(9),o=(n(0),n(234)),r=n(239),s=n(237),c=n(236),l=n(246),d=(n(235),n(245)),h=n(240),p=n(247),u=n(249),b={id:"TextsAndFonts",title:"Texts and Fonts"},g={id:"Development/UIDevelopment/TouchGFXEngineFeatures/TextsAndFonts",title:"Texts and Fonts",description:"import Link from '@docusaurus/Link';\r",source:"@site/docs\\Development\\UIDevelopment\\TouchGFXEngineFeatures\\TextsAndFonts.mdx",permalink:"/docs/Development/UIDevelopment/TouchGFXEngineFeatures/TextsAndFonts",sidebar:"docs",previous:{title:"Backend Communication",permalink:"/docs/Development/UIDevelopment/TouchGFXEngineFeatures/backend-communication"},next:{title:"Button",permalink:"/docs/Development/UIDevelopment/UIComponents/Buttons/Button"}},x=[{value:"Texts and Typographies",id:"texts-and-typographies",children:[]},{value:"The Text Converter",id:"the-text-converter",children:[]},{value:"The Font Converter",id:"the-font-converter",children:[]},{value:"Character Memory Optimization",id:"character-memory-optimization",children:[]},{value:"Wildcards",id:"wildcards",children:[{value:"Using Wildcards in TouchGFX Designer",id:"using-wildcards-in-touchgfx-designer",children:[]}]},{value:"Using Text in User Code",id:"using-text-in-user-code",children:[{value:"Displaying Texts in an Application",id:"displaying-texts-in-an-application",children:[]},{value:"Using Wildcards in User Code",id:"using-wildcards-in-user-code",children:[]}]},{value:"Text Placement",id:"text-placement",children:[{value:"Alignment",id:"alignment",children:[]},{value:"Setting the Correct Width and Height of a TextArea",id:"setting-the-correct-width-and-height-of-a-textarea",children:[]},{value:"Setting the Correct X and Y for a TextArea",id:"setting-the-correct-x-and-y-for-a-textarea",children:[]},{value:"Automatic Wapping of Long Text Lines",id:"automatic-wapping-of-long-text-lines",children:[]}]},{value:"Switching Language",id:"switching-language",children:[{value:"In TouchGFX Designer",id:"in-touchgfx-designer",children:[]}]}],m={rightToc:x},T="wrapper";function f(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(o.b)(T,Object(a.a)({},m,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"Fonts and texts are a very important aspect of modern graphical user interfaces. It is important to be able to display high quality anti-aliased texts in all the languages that your application supports."),Object(o.b)("p",null,"TouchGFX supports creation and modification of texts and typographies through the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/Development/UIDevelopment/DesignerUserGuide/TextsView"}),"Texts View")," of TouchGFX Designer. The TouchGFX Designer outputs text and typography configurations into a spreadsheet located at ",Object(o.b)(l.a,{text:"assets/texts/texts.xlsx",mdxType:"InlineCode"}),".\nThis spreadsheet, along with font files are feed to the font- and text-converter tools, producing generated C++ code files, that TouchGFX can render."),Object(o.b)("p",null,"This article introduces the text and font converter tools and explains how to use the generated texts in an application through code and TouchGFX Designer."),Object(o.b)("h2",{id:"texts-and-typographies"},"Texts and Typographies"),Object(o.b)("p",null,"The texts, translations and typographies in a TouchGFX application are stored in the ",Object(o.b)(l.a,{text:"assets/texts/texts.xlsx",mdxType:"InlineCode"}),' spreadsheet. This spreadsheet consists of two sheets. One defining the typographies used in the application and one defining the texts and all their translations. This spreadsheet is commonly referred to as the "Text Database"'),Object(o.b)("p",null,"The typographies can be edited in TouchGFX Designer with the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/Development/UIDevelopment/DesignerUserGuide/TextsView"}),"Texts View"),", which allows for real-time editing and handling of texts and translations. ",Object(o.b)(c.a,{text:"It is also possible to edit the typographies and texts directly in the texts.xlsx spreadsheet. However, when doing this, the TouchGFX Designer must be shutdown as it locks the texts.xlsx file while open.",mdxType:"InlineNote"})),Object(o.b)(d.a,{mdxType:"FurtherReading"},"To learn more about how to create and edit typographies, texts, translations and languages go to ",Object(o.b)(r.a,{to:"/docs/Development/UIDevelopment/DesignerUserGuide/TextsView",mdxType:"Link"},"Texts View")),Object(o.b)(u.a,{mdxType:"Note"},"For Glyph Bitmap Distribution Format fonts (.bdf), not all font sizes can be rendered with the font. If the given size in the typography sheet does not match with the given font, the font convert utility will report the supported font sizes. Updating the size in the Typography Sheet to one of the supported sizes will solve the problem."),Object(o.b)("h2",{id:"the-text-converter"},"The Text Converter"),Object(o.b)("p",null,"The text converter is the tool that converts the text information in the text database to an internal C++ format used by TouchGFX applications. The tool is an integrated part of the build tool-chain and will be executed automatically when building the simulator. The text converter is not executed if the text database has not been updated since the last build."),Object(o.b)(s.a,{imageSource:"/img/Development/UIDevelopment/TouchGFXEngineFeatures/TextsAndFonts/text-converter.png",mdxType:"Figure"}),Object(o.b)(u.a,{mdxType:"Note"},"The output directory of the text converter is ",Object(o.b)(l.a,{text:"generated/texts/",mdxType:"InlineCode"})),Object(o.b)("h2",{id:"the-font-converter"},"The Font Converter"),Object(o.b)("p",null,"The font converter is a tool that combines the information in font files with information in the text database and generates the characters needed by the application. The output format is an internal C++ format used by TouchGFX applications. The tool is an integrated part of the build tool-chain and will be executed automatically when building the simulator."),Object(o.b)(s.a,{imageSource:"/img/Development/UIDevelopment/TouchGFXEngineFeatures/TextsAndFonts/font-converter.png",mdxType:"Figure"}),Object(o.b)("p",null,"The Font Converter accepts"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"TrueType (.ttf)"),Object(o.b)("li",{parentName:"ul"},"OpenType (.otf)"),Object(o.b)("li",{parentName:"ul"},"Glyph Bitmap Distribution Format (.bdf).")),Object(o.b)("p",null,"Simply place the font in the ",Object(o.b)(l.a,{text:"assets/fonts/",mdxType:"InlineCode"})," folder and the font will be available for reference in TouchGFX Designer ",Object(o.b)(c.a,{text:"(If the font is added while TouchGFX Designer is running, it must be restarted to update the available fonts)",mdxType:"InlineNote"}),"."),Object(o.b)("p",null,"The Font Converter supports kerning by using the kerning information in the supplied font."),Object(o.b)(u.a,{mdxType:"Note"},Object(o.b)("li",null,"Using TouchGFX does not in any way provide licenses for commercial use of any TrueType, OpenType or Bitmap fonts."),Object(o.b)("li",null,"The output directory of the font converter is generated/fonts/.")),Object(o.b)("h2",{id:"character-memory-optimization"},"Character Memory Optimization"),Object(o.b)("p",null,"TouchGFX is optimized for low memory consumption. By analysing the characters used for a specific typography, the number of generated characters (in internal C++ format) are minimized down to the characters that are actually used by the application."),Object(o.b)("p",null,"Text memory consumption is also optimized by compacting texts that use common suffixes by enabeling the option to remap texts in the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/Development/UIDevelopment/DesignerUserGuide/ConfigView#text-configuration"}),"Text Configuration")),Object(o.b)("h2",{id:"wildcards"},"Wildcards"),Object(o.b)("p",null,"It is possible to use runtime values as part of texts. This is possible by use of wildcards in the texts. These are specified in the given format ",Object(o.b)("inlineCode",{parentName:"p"},"<*>"),", where the * represents an optional helping text which will not be included in the resulting text. It is possible to have up to two wildcards in one text."),Object(o.b)("p",null,"All translations for a given text must contain the same number of wildcards. The wildcard values are inserted at runtime in the application C++ code."),Object(o.b)("p",null,"Example of wildcard usage: ",Object(o.b)("strong",{parentName:"p"},"The temperature is ","<","insert_temperature",">","\xb0")),Object(o.b)("p",null,'One detail to notice is that due to the character memory optimization (see section above) the only characters that are generated for a specific typography are the ones used in texts having this typography. To force the font generator to include certain characters, you can use "',Object(o.b)(c.a,{text:"Wildcard Characters",mdxType:"InlineNote"}),'" and "',Object(o.b)(c.a,{text:"Character Ranges",mdxType:"InlineNote"}),'" for each typography.'),Object(o.b)("p",null,"The wildcard format ",Object(o.b)("inlineCode",{parentName:"p"},"<*>")," can be escaped by using backslash notation like this: ",Object(o.b)("strong",{parentName:"p"},"\\","<","not a wildcard\\",">"),'. This will result in the literal text "',Object(o.b)(c.a,{text:"<not a wildcard>",mdxType:"InlineNote"}),'" being used in the application.'),Object(o.b)("h3",{id:"using-wildcards-in-touchgfx-designer"},"Using Wildcards in TouchGFX Designer"),Object(o.b)("p",null,"In TouchGFX Designer, wildcards can be added to regular TextAreas. Effectively this now makes the TextArea widget cover the functionality previously covered by the TextAreaWithOneWildcard/TextAreaWithTwoWildcards widgets, although there is no changes to how the code is generated in TouchGFX."),Object(o.b)("p",null,"In TouchGFX Designer you can add Wildcards to TextAreas by either using the usual syntax ",Object(o.b)("inlineCode",{parentName:"p"},"<*>"),", or by simply clicking the ",Object(o.b)(c.a,{text:"Add Wildcard",mdxType:"InlineNote"})," button in properties for the selected TextArea. A well-known example is adding a temperature reading to a TextArea, which could say ",Object(o.b)(c.a,{text:"The temperature is \xb0",mdxType:"InlineNote"}),". In this case it could be an outdoor temperature reading. Here we want to insert a Wildcard that not only displays a number, but also updates according to temperature readings. The Wildcard will be added to the current position of the in-text caret:"),Object(o.b)(s.a,{imageSource:"/img/Development/UIDevelopment/TouchGFXEngineFeatures/TextsAndFonts/adding-wild-card-to-text-area.png",caption:"Adding a wildcard to a Text Area widget",mdxType:"Figure"}),Object(o.b)("p",null,"Now our text in properties will display ",Object(o.b)(c.a,{text:"The temperature is <value>\xb0",mdxType:"InlineNote"}),", while our text on canvas displays ",Object(o.b)(c.a,{text:"The temperature is  \xb0",mdxType:"InlineNote"}),":"),Object(o.b)(s.a,{imageSource:"/img/Development/UIDevelopment/TouchGFXEngineFeatures/TextsAndFonts/temperature-wildcard-example.png",caption:"Text Area widget with wildcard in TouchGFX Designer",mdxType:"Figure"}),Object(o.b)("p",null,"To setup the specific wildcard you can click the corresponding Wildcard button (in this example Wildcard 1), which allows for editing the Wildcard we just added."),Object(o.b)("p",null,"Here you can choose how you will update the wildcard. Either with predefined resource texts or by dynamic run-time created texts. In both cases, you can update the text at run-time. For the latter you need a Wildcard buffer for storing the dynamic text. Such a buffer is created by selecting the ",Object(o.b)(h.a,{name:"Wildcard Buffer",mdxType:"Property"})," check mark. In this case you also need to specify a size (number of characters) of the buffer. If you want to be memory efficient, you need to match the specified size as close as possible with your actual needed text size. Remember to add one extra space for the string termination (\u2018\\0\u2019)."),Object(o.b)("p",null,"You can also set an initial value for the Wildcard, enabling you to see how the final TextArea could look with a temperature reading. Setting an initial value will either create a hard coded Single Use text in the Text Database or if you have selected to use Wildcard buffer insert it into the Wildcard buffer:"),Object(o.b)(s.a,{imageSource:"/img/Development/UIDevelopment/TouchGFXEngineFeatures/TextsAndFonts/wildcard-setup-in-touchgfx-deisgner.png",caption:"Wildcard settings in TouchGFX Designer",mdxType:"Figure"}),Object(o.b)("h2",{id:"using-text-in-user-code"},"Using Text in User Code"),Object(o.b)("p",null,"This section describes how to use the generated texts from the text database in a TouchGFX application."),Object(o.b)("p",null,"The text converter converts all the texts specified in the text database into the text format used by TouchGFX. The format is wrapped in an object called ",Object(o.b)("inlineCode",{parentName:"p"},"TypedText"),". A ",Object(o.b)("inlineCode",{parentName:"p"},"TypedText")," in TouchGFX is a combined entity of the text contents itself and the typography of the text. The typography contains, the font and font size of the text and the bits per pixel (bpp) used in anti aliasing the glyphs of the font."),Object(o.b)("p",null,"The text converter generates a file called ",Object(o.b)(l.a,{text:"generated/texts/include/texts/TextKeysAndLanguages.hpp",mdxType:"InlineCode"}),". This file contains an enum ",Object(o.b)("inlineCode",{parentName:"p"},"TEXTS")," that references all texts in the text database. Notice that all entries in the enum are generated from the text id stated in each row in the text database, but with a T_ prepended and converted to uppercase. These enum values are used in applications to initialize TypedTexts.\nThe ",Object(o.b)(l.a,{text:"TextKeysAndLanguages.hpp",mdxType:"InlineCode"})," also contains an enum ",Object(o.b)("inlineCode",{parentName:"p"},"LANGUAGES")," that specifies all the languages that are present in the text database. The naming is the same as in the language column in the text database."),Object(o.b)(p.a,{mdxType:"CodeHeader"},"generated/texts/include/texts/TextKeysAndLanguages.hpp"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cpp"}),"/* DO NOT EDIT THIS FILE */\n/* This file is autogenerated by the text-database code generator */\n\n#ifndef TEXT_KEYS_AND_LANGUAGES_HPP\n#define TEXT_KEYS_AND_LANGUAGES_HPP\n\n\ntypedef enum {\n    GB,\n    DE,\n    NUMBER_OF_LANGUAGES\n} LANGUAGES;\n\n\ntypedef enum {\n    T_TEMPERATURE_READOUT,\n    T_TEMPERATURE_HEADLINE,\n    NUMBER_OF_TEXT_KEYS\n} TEXTS;\n\n#endif /* TEXT_KEYS_AND_LANGUAGES_HPP */\n")),Object(o.b)("h3",{id:"displaying-texts-in-an-application"},"Displaying Texts in an Application"),Object(o.b)("p",null,"In order to display a TypedText on the screen you can use the TextArea widget."),Object(o.b)(p.a,{mdxType:"CodeHeader"},"gui/include/gui/some_screen/SomeView.hpp"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cpp"}),"#include <touchgfx/widgets/TextArea.hpp>\n...\nclass SomeView : public View<SomePresenter>\n{\n  TextArea txt;\n}\n")),Object(o.b)(p.a,{mdxType:"CodeHeader"},"gui/src/some_screen/SomeView.cpp"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cpp"}),"#include <texts/TextKeysAndLanguages.hpp>\n#include <touchgfx/Color.hpp>\n\nvoid SomeView::setupScreen()\n{\n  txt.setTypedText(TypedText(T_TEMPERATURE_HEADLINE));\n  txt.setXY(10, 20);\n  txt.setColor(Color::getColorFrom24BitRGB(0xFF, 0xFF, 0xFF))\n  add(txt);\n}\n")),Object(o.b)("p",null,"We set the TypedText of the TextArea and set the X and Y coordinates and the color of the text in the ",Object(o.b)("inlineCode",{parentName:"p"},"setupScreen()")," method of the view class. Finally the TextArea is added to the current view."),Object(o.b)("h3",{id:"using-wildcards-in-user-code"},"Using Wildcards in User Code"),Object(o.b)("p",null,"TypedTexts can contain wildcards, making texts with dynamic content possible. This is specified in a text by using the special syntax ",Object(o.b)(c.a,{text:"<*>",mdxType:"InlineNote"}),". This corresponds closely to having a %s in a regular string in C++."),Object(o.b)("p",null,"Using wildcard text in an application is done by managing and updating a local ",Object(o.b)("inlineCode",{parentName:"p"},"Unicode::UnicodeChar")," array."),Object(o.b)(p.a,{mdxType:"CodeHeader"},"gui/include/gui/some_screen/SomeView.hpp"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cpp"}),"#include <touchgfx/widgets/TextAreaWithWildcard.hpp>\n...\nclass SomeView : public View<SomePresenter>\n{\n  TextAreaWithOneWildcard txt;\n  Unicode::UnicodeChar txtBuffer[10];\n}\n")),Object(o.b)(p.a,{mdxType:"CodeHeader"},"gui/src/some_screen/SomeView.cpp"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cpp"}),'#include <texts/TextKeysAndLanguages.hpp>\n#include <touchgfx/Color.hpp>\n\nvoid SomeView::setupScreen()\n{\n  txt.setTypedText(TypedText(T_TEMPERATURE_READOUT));\n  txt.setXY(10, 20);\n  txt.setColor(Color::getColorFrom24BitRGB(0xFF, 0xFF, 0xFF))\n  txt.setWildcard(txtBuffer);\n  add(txt);\n\n  updateTxt(5);\n}\n\nvoid SomeView::updateTxt(int newValue)\n{\n  Unicode::snprintf(txtBuffer, 10, "%d", newValue);\n  txt.invalidate();\n}\n')),Object(o.b)("h2",{id:"text-placement"},"Text Placement"),Object(o.b)("p",null,"As for all TouchGFX widgets a TextArea is placed on the screen by specifing a position (X and Y) and a dimension (width and height). However, there are a few more details and possibilites to be aware of when dealing with texts."),Object(o.b)("h3",{id:"alignment"},"Alignment"),Object(o.b)("p",null,"The text inside the TextArea is aligned according to the alignment specified for the chosen text entry in the text database. The text is aligned with respect to the area of the TextArea. In the following screenshots the area of the TextArea is highlighted in blue."),Object(o.b)(s.a,{imageSource:"/img/Development/UIDevelopment/TouchGFXEngineFeatures/TextsAndFonts/text-left-align.png",caption:"Left aligned text",mdxType:"Figure"}),Object(o.b)(s.a,{imageSource:"/img/Development/UIDevelopment/TouchGFXEngineFeatures/TextsAndFonts/text-center-align.png",caption:"Center aligned text",mdxType:"Figure"}),Object(o.b)(s.a,{imageSource:"/img/Development/UIDevelopment/TouchGFXEngineFeatures/TextsAndFonts/text-right-align.png",caption:"Right aligned text",mdxType:"Figure"}),Object(o.b)("h3",{id:"setting-the-correct-width-and-height-of-a-textarea"},"Setting the Correct Width and Height of a TextArea"),Object(o.b)("p",null,"A TextArea is able to adjust its width and height according to the currently selected text. This is done by calling the ",Object(o.b)(l.a,{text:"TextArea::resizeToCurrentText()",mdxType:"InlineCode"})," method."),Object(o.b)(u.a,{mdxType:"Note"},Object(o.b)(l.a,{text:"resizeToCurrentText()",mdxType:"InlineCode"})," is called automatically when instantiating a TextArea with a new TypedText if the width and height are not set."),Object(o.b)("p",null,"When using center/right aligned text you most often do not want to resize the width and height because your text need to be centered/right aligned in a fixed area. In this case set the width and height manually. This can be done by calling ",Object(o.b)(l.a,{text:"TextArea::setPosition(x, y, width, height)",mdxType:"InlineCode"}),", ",Object(o.b)(l.a,{text:"TextArea::setWidth(width)",mdxType:"InlineCode"})," and ",Object(o.b)(l.a,{text:"TextArea::setHeight(height)",mdxType:"InlineCode"}),"."),Object(o.b)("p",null,"If your width and/or height is too small to fit the text, the text will be clipped to the area as can be seen below."),Object(o.b)(s.a,{imageSource:"/img/Development/UIDevelopment/TouchGFXEngineFeatures/TextsAndFonts/text-cutoff.png",caption:"Text cutoff by the bounds of the TextArea widget size",mdxType:"Figure"}),Object(o.b)("h3",{id:"setting-the-correct-x-and-y-for-a-textarea"},"Setting the Correct X and Y for a TextArea"),Object(o.b)("p",null,"To place a TextArea at the correct X and Y position, you need to be aware of the fact that the font used will have some extra spacing above the characters to allow for large characters. This makes it a bit hard to place a TextArea according to a Y position for the upper left corner, since you do not know the exact spacing above your text.\nOne way of placing a text is to specify the position where you believe it should be and then fine tune the position by inspecting the placement in the simulator. This is most often a fairly simple task but it has to be redone if you change the font or font size later on."),Object(o.b)("p",null,'A more robust way of doing it is to use text baseline. The baseline is the line upon which most letters "sit" and below which descenders (characters like p and j) extend.'),Object(o.b)(s.a,{imageSource:"/img/Development/UIDevelopment/TouchGFXEngineFeatures/TextsAndFonts/text-baseline.png",caption:"Baseline for text",mdxType:"Figure"}),Object(o.b)("p",null,"To set a text baseline use the ",Object(o.b)(l.a,{text:"TextArea::setBaselineY(y)",mdxType:"InlineCode"})," or ",Object(o.b)(l.a,{text:"TextArea::setXBaselineY(x, y)",mdxType:"InlineCode"}),". For these methods you do not specify the upper left corner of the TextArea but instead the baseline of the first text line. This will take the font size and spacing into account and set the Y position of the TextArea accordingly."),Object(o.b)(u.a,{mdxType:"Note"},"The TextArea need to have its TypedText set before calling setBaselineY since it relies on the font. Also be aware that you need to call ",Object(o.b)(l.a,{text:"setBaselineY",mdxType:"InlineCode"})," again if you change the TextAreas TypedText to one with a different font or font size."),Object(o.b)("h3",{id:"automatic-wapping-of-long-text-lines"},"Automatic Wapping of Long Text Lines"),Object(o.b)("p",null,"Sometimes a TextArea needs to contain text which is very long. By default, such text is simply written as a single line and all text that does not fit inside the TextArea is simpy cut off. If instead the text should be wrapped at spaces and re-flowed to fill several lines, simply call:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cpp"}),"myTextArea.setWideTextAction(WIDE_TEXT_WORDWRAP); // Default is WIDE_TEXT_NONE\n")),Object(o.b)("p",null,"This will probably make the TextArea need more vertical space, and this can be taken care of by adjusting the height of the TextArea using"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cpp"}),"myTextArea.setWidth(200);\nmyTextArea.resizeHeightToCurrentText(); // Will set height by wrapping text at 200px long lines\n")),Object(o.b)("p",null,"Remember to call ",Object(o.b)(l.a,{text:"myTextArea.invalidate()",mdxType:"InlineCode"})," before and/or after resizing ",Object(o.b)("inlineCode",{parentName:"p"},"myTextArea"),"."),Object(o.b)("h2",{id:"switching-language"},"Switching Language"),Object(o.b)("p",null,"TouchGFX supports multi language interfaces. The current language used in the interface can be changed by calling the static method ",Object(o.b)(l.a,{text:" Texts::setLanguage",mdxType:"InlineCode"}),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cpp"}),"Texts::setLanguage(GB);\n")),Object(o.b)("p",null,"The value ",Object(o.b)(c.a,{text:"GB",mdxType:"InlineNote"})," is found in the ",Object(o.b)(l.a,{text:"LANGUAGES",mdxType:"InlineCode"})," enum in the ",Object(o.b)(l.a,{text:"TextKeysAndLanguages.hpp",mdxType:"InlineCode"}),"."),Object(o.b)("p",null,"After this call, invalidate all widgets that display texts (or simply invalidate the entire screen) and they will display texts in the newly selected language."),Object(o.b)("h3",{id:"in-touchgfx-designer"},"In TouchGFX Designer"),Object(o.b)("p",null,"You can swap between languages, enabling testing for all translations. This is done from ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/Development/UIDevelopment/DesignerUserGuide/ConfigView#general"}),"General section of the Config view"),". Here you simply change the startup language of the application by changing the ",Object(o.b)(h.a,{name:"Selected Language",mdxType:"Property"}),". Languages will need to be created and translated before they are selectable in the Config view."))}f.isMDXComponent=!0},235:function(e,t,n){"use strict";var a=n(5),i=n(0),o=n.n(i),r=n(238),s=o.a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},o.a.createElement("path",{"fill-rule":"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"})),c=function(e){function t(){return e.apply(this,arguments)||this}return Object(a.a)(t,e),t.prototype.render=function(){return o.a.createElement(r.a,{color:"var(--highlight-color-tip)",header:"Tip",type:"tip",icon:s},this.props.children)},t}(i.Component);t.a=c},236:function(e,t,n){"use strict";var a=n(5),i=n(0),o=n.n(i),r=function(e){function t(){return e.apply(this,arguments)||this}return Object(a.a)(t,e),t.prototype.render=function(){return o.a.createElement("i",null,this.props.text)},t}(i.Component);t.a=r},240:function(e,t,n){"use strict";n(241);var a=n(5),i=n(0),o=n.n(i),r=function(e){function t(){return e.apply(this,arguments)||this}return Object(a.a)(t,e),t.prototype.render=function(){return o.a.createElement("i",null,this.props.name)},t}(i.Component);t.a=r},241:function(e,t,n){var a=n(23).f,i=Function.prototype,o=/^\s*function ([^ (]*)/;"name"in i||n(11)&&a(i,"name",{configurable:!0,get:function(){try{return(""+this).match(o)[1]}catch(e){return""}}})},249:function(e,t,n){"use strict";var a=n(5),i=n(0),o=n.n(i),r=n(238),s=o.a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},o.a.createElement("path",{"fill-rule":"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})),c=function(e){function t(){return e.apply(this,arguments)||this}return Object(a.a)(t,e),t.prototype.render=function(){return o.a.createElement(r.a,{color:"var(--highlight-color-note)",header:"Note",type:"note",icon:s},this.props.children)},t}(i.Component);t.a=c}}]);