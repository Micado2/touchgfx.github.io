(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{205:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return l})),a.d(t,"metadata",(function(){return d})),a.d(t,"rightToc",(function(){return h})),a.d(t,"default",(function(){return u}));var n=a(1),i=a(9),o=(a(0),a(256)),s=(a(259),a(257)),r=a(270),c=(a(268),a(271),a(265),a(272),a(269)),l=(a(258),a(266),{id:"CanvasWidgets",title:"Canvas Widgets"}),d={id:"Development/UIDevelopment/TouchGFXEngineFeatures/CanvasWidgets",title:"Canvas Widgets",description:"import Link from '@docusaurus/Link';",source:"@site/docs\\Development\\UIDevelopment\\TouchGFXEngineFeatures\\CanvasWidgets.mdx",permalink:"/docs/Development/UIDevelopment/TouchGFXEngineFeatures/CanvasWidgets",sidebar:"docs",previous:{title:"Custom Widgets",permalink:"/docs/Development/UIDevelopment/TouchGFXEngineFeatures/CustomWidgets"},next:{title:"Dynamic Bitmaps",permalink:"/docs/Development/UIDevelopment/TouchGFXEngineFeatures/DynamicBitmaps"}},h=[{value:"Using CanvasWidgets",id:"using-canvaswidgets",children:[]},{value:"Memory Allocation and Usage",id:"memory-allocation-and-usage",children:[{value:"Memory Allocation in TouchGFX Designer",id:"memory-allocation-in-touchgfx-designer",children:[]},{value:"Memory Allocation in User Code",id:"memory-allocation-in-user-code",children:[]}]},{value:"The CWR Coordinate System",id:"the-cwr-coordinate-system",children:[]},{value:"Custom Canvas Widgets",id:"custom-canvas-widgets",children:[]},{value:"Painters",id:"painters",children:[]}],p={rightToc:h},m="wrapper";function u(e){var t=e.components,a=Object(i.a)(e,["components"]);return Object(o.b)(m,Object(n.a)({},p,a,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"Canvas Widgets and the Canvas Widget Renderer are a powerful and versatile add-on to TouchGFX which provides nice smooth, anti-aliased drawing of geometric shapes using relatively little memory while maintaining high performance. However, rendering geometrical shapes must be seen as a quite expensive operation and can easily strain the microcontrollers resources if not used carefully."),Object(o.b)("p",null,"The Canvas Widget Renderer (hereafter referred to as CWR) is a general graphics API, providing optimized drawing for primitives, automatically eliminating most superfluous drawings. CWR is used by TouchGFX for drawing complex geometric shapes. Geometric shapes are defined by Canvas Widgets. TouchGFX comes with a number of supported Canvas Widgets but just like normal widgets you can make your own custom Canvas Widget to match your needs. Where a Canvas Widget defines the geometric shape of a figure to be drawn by the CWR, the actual color of each pixel inside the figure is defined by an associated Painter class. Again, TouchGFX comes with a number of Painters but you can make your own custom Painters to match your needs."),Object(o.b)("h2",{id:"using-canvaswidgets"},"Using CanvasWidgets"),Object(o.b)("p",null,"Other widgets in TouchGFX have their sizes set automatically. A bitmap widget, for example, will automatically get the width and height of the contained bitmap. It is therefore enough to use ",Object(o.b)(c.a,{text:"setXY()",mdxType:"InlineCode"})," on the bitmap widget to place the bitmap on the display."),Object(o.b)("p",null,"Canvas Widgets do not have a default size which can be determined automatically and set initially. Care must be taken to not only position, but also size the widget correctly, otherwise the width and height of the Canvas Widget will be zero, and nothing will be drawn on the display."),Object(o.b)("p",null,"So, instead of using ",Object(o.b)(c.a,{text:"setXY()",mdxType:"InlineCode"}),", use ",Object(o.b)(c.a,{text:"setPosition()",mdxType:"InlineCode"})," to place and size the canvas widget. See also Custom Canvas Widgets below for an example on how to create and use a custom canvas widget."),Object(o.b)("p",null,"Once the position and size of the Canvas Widget has been set, a geometrical shape can be drawn inside it. The coordinate system will have (0, 0) in the upper left corner of the widget (not the display), the X axis stretches to the right and the Y axis stretches downwards."),Object(o.b)("p",null,"Canvas widgets are also supported in TouchGFX Designer, and makes the usage simple and has automatic memory allocation."),Object(o.b)("p",null,"Available CanvasWidget based widgets in TouchGFXDesigner:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"/docs/Development/UIDevelopment/UIComponents/Shapes/Line"}),"Line")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"/docs/Development/UIDevelopment/UIComponents/Shapes/Circle"}),"Circle")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"/docs/Development/UIDevelopment/UIComponents/Shapes/Shape"}),"Shape")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"/docs/Development/UIDevelopment/UIComponents/ProgressIndicators/LineProgress"}),"LineProgress")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"/docs/Development/UIDevelopment/UIComponents/ProgressIndicators/CircleProgress"}),"CircleProgress"))),Object(o.b)("p",null,"Using these widget via TouchGFX Designer, makes placement and size adjustment much easier by showing how the widget will look at run time."),Object(o.b)("h2",{id:"memory-allocation-and-usage"},"Memory Allocation and Usage"),Object(o.b)("p",null,"To produce nice anti-aliased complex geometrical shapes additional memory is required. For this CWR has to have a special allocated memory buffer that is used during rendering. CWR, as the rest of TouchGFX, has no dynamic memory allocation."),Object(o.b)("h3",{id:"memory-allocation-in-touchgfx-designer"},"Memory Allocation in TouchGFX Designer"),Object(o.b)("p",null,"When adding a widget to the canvas of a Screen a memory buffer is automatically generated. The size of the buffer is based upon the width of the Screen with the following formula (Width ","\xd7"," 3) ","\xd7"," 5.\nThis is however not always the ideal buffer size for all scenarios. Therefore the buffer size can be overridden has shown in the image below."),Object(o.b)(s.a,{imageSource:"/img/Development/UIDevelopment/TouchGFXEngineFeatures/CanvasWidgets/screen-canvas-buffer-override.png",caption:"Canvas buffer size being overridden in Screen properties",mdxType:"Figure"}),Object(o.b)("h3",{id:"memory-allocation-in-user-code"},"Memory Allocation in User Code"),Object(o.b)("p",null,"The memory buffer can be allocated and setup in ",Object(o.b)(c.a,{text:"target/main.cpp",mdxType:"InlineCode"})," and ",Object(o.b)(c.a,{text:"simulator/main.cpp",mdxType:"InlineCode"})," or be setup and allocated per Screen."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp"}),"static const uint16_t CANVAS_BUFFER_SIZE = 3600;\nstatic uint8_t canvasBuffer[CANVAS_BUFFER_SIZE]\n")),Object(o.b)("p",null,"A static const defining the size of the memory buffer, and the actual memory buffer can be defined in the beginning of the ",Object(o.b)(c.a,{text:"main.cpp",mdxType:"InlineCode"})," or ",Object(o.b)(c.a,{text:"ScreenView.hpp",mdxType:"InlineCode"})),Object(o.b)("p",null,"Then in either the ",Object(o.b)(c.a,{text:"main()",mdxType:"InlineCode"})," method of ",Object(o.b)(c.a,{text:"main.cpp",mdxType:"InlineCode"})," or ",Object(o.b)(c.a,{text:"setupScreen()",mdxType:"InlineCode"})," method of ",Object(o.b)(c.a,{text:"ScreenView.cpp",mdxType:"InlineCode"})," the following line setting op the buffer can be added."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp"}),"CanvasWidgetRenderer::setupBuffer(canvasBuffer, CANVAS_BUFFER_SIZE);\n")),Object(o.b)("p",null,"The amount of CWR memory needed depends on the maximum size of the shapes that are to be drawn in the application. You can, however, reserve less memory than the maximum shape requires. To handle this situation the CWR split up drawings of shapes into smaller frame buffer parts resulting in slightly longer rendering time, as shapes in these cases will sometimes have to be rendered more than once.\nIt is possible to investigate and fine-tune the memory consumption closer when running in simulator mode. Simply add the following function call to your main.cpp:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp"}),"CanvasWidgetRenderer::setWriteMemoryUsageReport(true);\n")),Object(o.b)("p",null,"Now whenever a draw operation finishes, CWR will report (print in the console) how much memory was required. For canvas_widget_example this could be \u201cCWR requires 3604 bytes\u201d (for the first draw operation) followed by \u201cCWR requiers 7932 bytes (4328 bytes missing)\u201d (for the second draw operation).\nEven though it appears that CWR does not have enough memory (4328 bytes missing in this case) the application runs fine. This is because CWR detects that too little memory is available to complete the complex draw operation in a single run. Instead it splits the draw operation into two separate draw operations and the shape will be drawn just fine but will require more time to render."),Object(o.b)("p",null,"Setting the correct memory buffer size is therefore a trade off between memory and performance (rendering time). A good starting value is usually around 3000, but using the above technique, a better value can often be determined. If the shape is too complex and the allocated memory buffer is too small, part of the shape will not be drawn (some vertical pixel lines will be skipped) and it is possible that nothing is drawn at all. In any case rendering time will increase a lot."),Object(o.b)("p",null,"This means that if you want your application to render the CWR drawing at maximum speed you need to allocate the requested amount om memory. But if you can go with a slower rendering timer it is perfectly okay to reduce the memory buffer."),Object(o.b)("h2",{id:"the-cwr-coordinate-system"},"The CWR Coordinate System"),Object(o.b)("p",null,"The coordinate system in TouchGFX is normally used to address pixels for positioning bitmaps on the display. Bitmaps, texts and other graphic elements are all placed in a coordinate system, where (0,0) is the upper left hand pixel, the x-axis extends to the right and the y-axis extends downwards. In CWR it is not enough to be able to address pixels using integers, though this might be enough in special cases, this is far from enough in general. To demonstrate this, consider a circle with line width 1, which must fit precisely inside a box of 5 by 5 pixels. The center of this circle must be at (2.5, 2.5) and the radius must be 2, so fractions are required for the center coordinate. Similarly, if the circle should fit inside a box of 6 by 6 pixels, the center must be at (3, 3) and the radius must be 2.5, so here fractions are required for the radius."),Object(o.b)("p",null,"This new way of addressing coordinates for drawing graphics, means that the center of the pixel at (0,0) has CWR coordinate (0.5, 0.5). Hence, the box containing the pixel in the upper left corner of the screen has the following outline: (0,0) -> (1,0) -> (1,1) -> (0,1) -> (0,0)."),Object(o.b)(s.a,{imageSource:"/img/Development/UIDevelopment/TouchGFXEngineFeatures/CanvasWidgets/cwr-coordinate-system.png",caption:"CWR coordinate system for pixel at (0,0)",mdxType:"Figure"}),Object(o.b)("p",null,"Though this might seem confusing at first, it quickly becomes very natural. Where the coordinate system for bitmaps address the pixels, the same coordinate for Canvas Widgets address the gap just before and above the pixel."),Object(o.b)("h2",{id:"custom-canvas-widgets"},"Custom Canvas Widgets"),Object(o.b)("p",null,"Implementing a custom Canvas Widget requires an implementation of a new class with the following functions:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp"}),"virtual bool drawCanvasWidget(const Rect& invalidatedArea) const;\nvirtual Rect getMinimalRect() const;\n")),Object(o.b)("p",null,"The ",Object(o.b)(c.a,{text:"drawCanvasWidget()",mdxType:"InlineCode"})," must draw whatever the custom widget needs to draw and ",Object(o.b)(c.a,{text:"getMinimalRect()",mdxType:"InlineCode"})," should return the actual rectangle in the Widget which contains the geometrical shape."),Object(o.b)(r.a,{mdxType:"Note"},"The reason for having ",Object(o.b)(c.a,{text:"getMinimalRect()",mdxType:"InlineCode"})," is that a geometrical shape can be moved around inside its widget and it is often impractical to resize and reposition the widget whenever the shape changes to only invalidate the smallest possible area.",Object(o.b)("p",null,"  A dummy implementation of ",Object(o.b)(c.a,{text:"getMinimalRect()",mdxType:"InlineCode"})," could simply  ",Object(o.b)(c.a,{text:"return rect;",mdxType:"InlineCode"}),", that is the size of the widget, but that would cause the entire area covered by the canvas widget to be redrawn, and not just the part of the canvas widget containing the geometrical shape. Very often, the geometrical shape occupies only a small part of the canvas widget.")),Object(o.b)("p",null,"Canvas Widgets all use the Canvas class, which encapsulates the Canvas Widget Renderer as described above. CWR has many optimizations applied automatically, though awareness of your geometrical shape in relation to the invalidated area, and avoiding unnecessary drawing outside the invalidated area, is always a good way to boost performance."),Object(o.b)("p",null,"A rough implementation of a diamond shaped square inside a 10x10 box could look something like this:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp"}),"class Diamond10x10 : public CanvasWidget\n{\npublic:\n  virtual Rect getMinimalRect() const\n  {\n    return Rect(0,0,10,10);\n  }\n  virtual bool drawCanvasWidget(const Rect& invalidatedArea) const\n  {\n    Canvas canvas(this, invalidatedArea);\n    canvas.moveTo(5,0);\n    canvas.lineTo(10,5);\n    canvas.lineTo(5,10);\n    canvas.lineTo(0,5);\n    return canvas.render(); // Shape is automatically closed\n  }\n};\n")),Object(o.b)(r.a,{mdxType:"Note"},"Again, be careful that ",Object(o.b)(c.a,{text:"getMinimalRect()",mdxType:"InlineCode"})," returns to correct rectangle, or the graphics on screen might be wrong."),Object(o.b)("p",null,"In order to see the Diamond10x10 on the display, the color must be set using ",Object(o.b)(c.a,{text:"Diamond10x10::setPainter()",mdxType:"InlineCode"})," inherited from CanvasWidget. Also, the Diamond10x10 must be placed and sized correctly. This could look similar to this:"),Object(o.b)("p",null,"In the header file declare"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp"}),"Diamond10x10 box;\nPainterRGB565 myPainter;\n")),Object(o.b)("p",null,"and in the code you should have something like this:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp"}),"myPainter.setColor(Color::getColorFrom24BitRGB(0xFF, 0x0, 0x0));\nbox.setPosition(100,100,10,10);\nbox.setPainter(myPainter);\nadd(box);\n")),Object(o.b)("h2",{id:"painters"},"Painters"),Object(o.b)("p",null,"A Painter defines a coloring scheme to fill a Canvas Widget object. TouchGFX comes with a set of predefined painter classes, but custom painters can easily be implemented."),Object(o.b)("p",null,"In order to implement a custom Painter, care must be taken to never write outside the frame buffer. Such a bug in a custom Painter can result in serious crashes. Here is an example of a custom Painter which we will use to paint an object red, only function ",Object(o.b)(c.a,{text:"renderNext()",mdxType:"InlineCode"})," needs to be implemented. See AbstractPainter for more information."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp"}),"class Red : public AbstractPainterRGB565\n{\npublic:\n    virtual bool renderNext(uint8_t &red, uint8_t &green, uint8_t &blue, uint8_t &alpha)\n    {\n        red = 0xFF;\n        green = 0x00;\n        blue = 0x00;\n        alpha = 0xFF;\n    }\n};\n")),Object(o.b)("p",null,"To paint the box object from above red, put this in the header file:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp"}),"Diamond10x10 box;\nRed redPaint;\n")),Object(o.b)("p",null,"and put this in the code:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp"}),"box.setPosition(100,100,10,10);\nbox.setPainter(redPaint);\nadd(box);\n")),Object(o.b)("p",null,"Please note that it is possible to override more methods to create special painters e.g. ",Object(o.b)(c.a,{text:"renderInit()",mdxType:"InlineCode"}),", however, TouchGFX has some generic painters which covers most uses."))}u.isMDXComponent=!0},258:function(e,t,a){"use strict";var n=a(5),i=a(0),o=a.n(i),s=function(e){function t(){return e.apply(this,arguments)||this}return Object(n.a)(t,e),t.prototype.render=function(){return o.a.createElement("i",null,this.props.text)},t}(i.Component);t.a=s},270:function(e,t,a){"use strict";var n=a(5),i=a(0),o=a.n(i),s=a(267),r=o.a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},o.a.createElement("path",{"fill-rule":"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})),c=function(e){function t(){return e.apply(this,arguments)||this}return Object(n.a)(t,e),t.prototype.render=function(){return o.a.createElement(s.a,{color:"var(--highlight-color-note)",header:"Note",type:"note",icon:r},this.props.children)},t}(i.Component);t.a=c},271:function(e,t,a){"use strict";var n=a(5),i=a(0),o=a.n(i),s=a(267),r=o.a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},o.a.createElement("path",{"fill-rule":"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})),c=function(e){function t(){return e.apply(this,arguments)||this}return Object(n.a)(t,e),t.prototype.render=function(){return o.a.createElement(s.a,{color:"var(--highlight-color-try)",header:"Things to try",type:"try",icon:r},this.props.children)},t}(i.Component);t.a=c},272:function(e,t,a){"use strict";var n=a(5),i=a(0),o=a.n(i),s=a(267),r=o.a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},o.a.createElement("path",{"fill-rule":"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"})),c=function(e){function t(){return e.apply(this,arguments)||this}return Object(n.a)(t,e),t.prototype.render=function(){return o.a.createElement(s.a,{color:"var(--highlight-color-caution)",header:"Caution",type:"caution",icon:r},this.props.children)},t}(i.Component);t.a=c}}]);