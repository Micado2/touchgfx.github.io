(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{133:function(e,t,r){"use strict";r.r(t),r.d(t,"frontMatter",(function(){return s})),r.d(t,"metadata",(function(){return c})),r.d(t,"rightToc",(function(){return f})),r.d(t,"default",(function(){return h}));var a=r(1),n=r(9),i=(r(0),r(227)),o=r(229),l=(r(232),r(230),r(234),r(266)),s={id:"LoweringMemoryUsageWithPartialFrameBuffer",title:"Lowering Memory Usage with Partial Framebuffer"},c={id:"Development/UIDevelopment/Scenarios/LoweringMemoryUsageWithPartialFrameBuffer",title:"Lowering Memory Usage with Partial Framebuffer",description:"import Figure from '@site/components/Figure';",source:"@site/docs\\Development\\UIDevelopment\\Scenarios\\LoweringMemoryUsageWithPartialFrameBuffer.mdx",permalink:"/docs/Development/UIDevelopment/Scenarios/LoweringMemoryUsageWithPartialFrameBuffer",sidebar:"docs",previous:{title:"Loading Images at Runtime",permalink:"/docs/Development/UIDevelopment/Scenarios/LoadingImagesAtRuntime"},next:{title:"Using Non-Memory Mapped Flash for Storing Images",permalink:"/docs/Development/UIDevelopment/Scenarios/UsingNonMemoryMappedFlashForStoringImages"}},f=[{value:"Full-size Frame Buffer memory",id:"full-size-frame-buffer-memory",children:[]},{value:"Partial Frame Buffer memory",id:"partial-frame-buffer-memory",children:[]},{value:"Display Tearing",id:"display-tearing",children:[]},{value:"Display update example",id:"display-update-example",children:[]},{value:"Configuring Partial Frame Buffers",id:"configuring-partial-frame-buffers",children:[]},{value:"Transferring Frame Buffers to the Screen",id:"transferring-frame-buffers-to-the-screen",children:[{value:"Transferring Frame Buffers on DSI Display",id:"transferring-frame-buffers-on-dsi-display",children:[]},{value:"Transferring Frame Buffers on SPI Display",id:"transferring-frame-buffers-on-spi-display",children:[]}]},{value:"Conclusion",id:"conclusion",children:[]}],u={rightToc:f},p="wrapper";function h(e){var t=e.components,r=Object(n.a)(e,["components"]);return Object(i.b)(p,Object(a.a)({},u,r,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"This article explains, exemplifying with a clock application, how to configure and use Partial Frame Buffers, to lower memory requirements at the expense of some performance."),Object(i.b)("p",null,"A video of the application running on the STM32L4R9 Discovery board can be seen below"),Object(i.b)(l.a,{url:"http://sw-center-st-com.s3-eu-west-1.amazonaws.com/touchgfx/TouchGFX/knowledgebase/Partial%20framebuffer/Partial%20framebuffer.mp4",mdxType:"Video"}),Object(i.b)("h2",{id:"full-size-frame-buffer-memory"},"Full-size Frame Buffer memory"),Object(i.b)("p",null,"Normally, your frame buffer is a big memory array with enough allocated memory to hold all the pixels available on your display. If you are running on a 24-bit display with a resolution of 480 x 272, a full-size frame buffer holds 480 x 272 x 3 bytes = 391.680 bytes."),Object(i.b)("p",null,'Some applications may have 2- ("Double buffering") or even 3 frame buffers. The total memory requirement in these cases would then be 783.360 and 1.175.040 bytes.'),Object(i.b)("p",null,"TouchGFX writes pixel values to the frame buffer when drawing any part of the UI, after all drawing operations have completed, the frame buffer is then transferred to the display. Typically, the whole frame buffer is transferred to the display even if only a part of the UI is updated. Generally, the framebuffer can be updated multiple times before it is transferred."),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},"Update1, Update 2, Update 3, ..., Update N, Transfer (LTDC)")),Object(i.b)("p",null,"In some cases, particularly in low cost solutions with no external RAM, frame buffers are required to be small enough to allow the rest of the application to fit; This is where partial frame buffers are useful."),Object(i.b)("h2",{id:"partial-frame-buffer-memory"},"Partial Frame Buffer memory"),Object(i.b)("p",null,"Partial frame buffers allows a TouchGFX application to run out of multiple, less than full-size frame buffers. which are configurable. This technique can lower the memory requirements of an application by a substantial amount, but comes with some limitations:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Partial frame buffers will only work on displays that have built-in memory. These are typically DSI displays or displays with a parallel bus connection (DBI type A/B, 8080/6800)."),Object(i.b)("li",{parentName:"ul"},"Potential tearing for complex applications")),Object(i.b)("p",null,"Rather than using a frame buffer representing every pixel on the display, partial frame buffers typically cover a smaller part. . In the clock example used in this article three frame buffers of 11.700 bytes each are used leaving us with a memory footprint for frame buffers of 35.100 bytes."),Object(i.b)("p",null,"Whenever the application needs to update a part of the UI, TouchGFX will select one of the configured, partial frame buffers, complete its drawing operation, and transfer that part to the display. This is repeated for all areas of the UI that need to be rendered - This changes the formula for updating and transferring data to:"),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},"Update1, Transfer1, Update2, Transfer2, Update3, Transfer3, ..., UpdateN, TransferN")),Object(i.b)("h2",{id:"display-tearing"},"Display Tearing"),Object(i.b)("p",null,"Contrary to using full-size frame buffers, TouchGFX will transfer parts of the UI as soon as they are updated, when using partial frame buffers. Because of this, updates to the display are not synchronized for an entire frame and will potentially be visible to the user before all updates have been transferred. The display will show an update on its glass after at most 16 ms (for 60 fps displays)."),Object(i.b)("p",null,"If the total sequence of draw operations and transfers take a long time to complete it is highly possible that the user will see a combination of the previous frame and some of the new updates. This is called display tearing and is not desirable. For this reason partial frame buffers are not suitable for applications that make use of complex animations that take a long time to render."),Object(i.b)("h2",{id:"display-update-example"},"Display update example"),Object(i.b)("p",null,"Before we get into how to configure partial frame buffers in your application let's have a look at a concrete example showing a digital clock with a moving circle arc representing seconds. The green circle arc is moving 6 degrees each second and does a full rotation in a minute. The UI is built from four Widgets as seen in the image below:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"/docs/Development/UIDevelopment/UIComponents/Shapes/Line"}),"Line")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"/docs/Development/UIDevelopment/UIComponents/Shapes/Circle"}),"Circle")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"/docs/Development/UIDevelopment/UIComponents/Miscellaneous/DigitalClock"}),"Digital Clock")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"/docs/Development/UIDevelopment/UIComponents/Shapes/Box"}),"Box"))),Object(i.b)(o.a,{imageSource:"/img/Development/UIDevelopment/Scenarios/LoweringMemoryUsageWithPartialFrameBuffer/touchgfx-designer-with-widgets.png",caption:"",mdxType:"Figure"}),Object(i.b)("p",null,"Here is the code that updates the digital clock and circle arc:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cpp"}),"void MainView::handleTickEvent()\n{\nticks++;\nif (ticks == 10)\n{\n    ticks = 0;\n    secs += 1;\n    if (secs == 60)\n    {\n    secs = 0;\n    min += 1;\n    if (min == 60)\n    {\n        min = 0;\n        hour += 1;\n        if (hour == 24)\n        {\n        hour = 0;\n        }\n    }\n    //Only update digital clock when minutes or hours change\n    digitalClock.setTime24Hour(hour, min, secs);\n    }\n    //Always update seconds\n    circleSeconds.updateArc(secs*6 - 20, secs*6);\n}\n}\n")),Object(i.b)("p",null,"The following images shows the areas that are updated in the first few seconds when the circle arc approaches the top and digital clock is updated (the grey rectangles):"),Object(i.b)(o.a,{imageSource:"/img/Development/UIDevelopment/Scenarios/LoweringMemoryUsageWithPartialFrameBuffer/simulator-updated-areas-1.png",caption:"",mdxType:"Figure"}),Object(i.b)(o.a,{imageSource:"/img/Development/UIDevelopment/Scenarios/LoweringMemoryUsageWithPartialFrameBuffer/simulator-updated-areas-2.png",caption:"",mdxType:"Figure"}),Object(i.b)(o.a,{imageSource:"/img/Development/UIDevelopment/Scenarios/LoweringMemoryUsageWithPartialFrameBuffer/simulator-updated-areas-3.png",caption:"",mdxType:"Figure"}),Object(i.b)(o.a,{imageSource:"/img/Development/UIDevelopment/Scenarios/LoweringMemoryUsageWithPartialFrameBuffer/simulator-updated-areas-4.png",caption:"",mdxType:"Figure"}),Object(i.b)("p",null,"The rectangles updated in the third image above are 154 x 60 pixels, 20 x 12 pixels, and 33 x 8 pixels. When using standard frame buffers these three rectangles would be drawn into the full frame buffer which would afterwards be transferred to the display. When using partial frame buffers, these three rectangles would be drawn into their own little frame buffers which would immediately be transferred to the display and shown."),Object(i.b)("h2",{id:"configuring-partial-frame-buffers"},"Configuring Partial Frame Buffers"),Object(i.b)("p",null,"There are two steps to configuring TouchGFX for partial frame buffers: Creating a frame buffer allocator object with a memory buffer, and configuring the TouchGFX HAL class to use it. Later we also need to write code to transmit the buffers to the display. The first two steps are typically done in the BoardConfiguration.cpp file."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Creating a frame buffer allocator as a global variable:"),Object(i.b)("br",null)),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cpp"}),"//2 or more blocks of 10*390 pixels\nManyBlockAllocator<10*390*3, 2, 3> frameBufferAllocator;\n")),Object(i.b)("p",null,"This frame buffer allocator allocates 2 blocks of each 10 x 390 x 3 bytes = 11.700 bytes."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Configure HAL to use it:"),Object(i.b)("br",null)),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cpp"}),"void touchgfx_init()\n{\n    HAL& hal = touchgfx_generic_init(dma, display, tc, GUI_DISPLAY_WIDTH,\n                                         GUI_DISPLAY_HEIGHT, 0, 0, 0);\n    hal.setFrameBufferStartAddress((uint16_t*)0, GUI_DISPLAY_BPP, false, false);\n    hal.setFrameBufferAllocator(&frameBufferAllocator);\n    hal.setFrameRefreshStrategy(HAL::REFRESH_STRATEGY_PARTIAL_FRAMEBUFFER);\n   ...\n")),Object(i.b)("p",null,"With this configuration TouchGFX will allocate small frame buffers and draw the UI in them. What is left now, is to transfer the small frame buffers to the display.\nLets first see the position and size of the two frame buffers allocated to draw the small circle updates (second image above):"),Object(i.b)("p",null,"Rectangle 1: x = 112, y = 56, width = 22, height =14, covers 308 pixels = 924 bytes",Object(i.b)("br",null),"\nRectangle 2: x = 153, y = 42, width = 29, height =11, covers 319 pixels = 957 bytes"),Object(i.b)("p",null,"In the third image above, we have 3 updated rectangles: The small updates to the circle, and the larger rectangle covering the TextArea:"),Object(i.b)("p",null,"Rectangle 1: x = 126, y = 51, width = 20, height = 12, covers 240 pixels = 720 bytes",Object(i.b)("br",null),"\nRectangle 2: x = 165, y = 42, width = 33, height = 8, covers 264 pixels = 792 bytes",Object(i.b)("br",null),"\nRectangle 3: x = 118, y = 165, width = 154, height = 60, covers 9.240 pixels = 27.720 bytes"),Object(i.b)("p",null,"In both cases the frame buffers 1 and 2 are so small, they can fit into the blocks allocated by the frame buffer allocator, but frame buffer 3 is to0 large.\nThis rectangle is to large and will be split into multiple blocks that each can fit into the frame buffers (11.700 bytes)."),Object(i.b)("h2",{id:"transferring-frame-buffers-to-the-screen"},"Transferring Frame Buffers to the Screen"),Object(i.b)("p",null,"TouchGFX will allocate a frame buffer from the FrameBufferAllocator object, when a rectangle needs to be redrawn. After drawing TouchGFX will call"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cpp"}),"void HAL::flushFrameBuffer(const Rect& rect);\n")),Object(i.b)("p",null,"This function can be overridden in a HAL subclass to transfer the frame buffer to the screen. The following sections will illustrate how to configure this for STM32L4R9 Discovery board which have a DSI screen, and STM32G081 with a DSI screen."),Object(i.b)("h3",{id:"transferring-frame-buffers-on-dsi-display"},"Transferring Frame Buffers on DSI Display"),Object(i.b)("p",null,"The STM32L4R9 Discovery uses a DSI display. The normal HAL class is called STM32HAL_DSI (located in target/bsp/target/STM32HAL_DSI.cpp)."),Object(i.b)("p",null,"We override the HAL::flushFrameBuffer method to notify the FrameBufferAllocator that a block has been drawn:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cpp"}),"void STM32HAL_DSI::flushFrameBuffer(const Rect& rect)\n{\n    frameBufferAllocator->markBlockReadyForTransfer();\n    HAL::flushFrameBuffer(rect);\n}\n")),Object(i.b)("p",null,"The FrameBufferAllocator subclass ManyBlockAllocator will call the global function FrameBufferAllocatorSignalBlockDrawn() when a block is ready for transfer. This method must be implemented in the BSP layer:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cpp"}),"void FrameBufferAllocatorSignalBlockDrawn()\n  {\n    if (!dsiIsTransferring)\n    {\n      sendBlock();\n    }\n  }\n")),Object(i.b)("p",null,'This function is calling the sendBlock function, unless a transfer is already ongoing on the DSI. For the first block drawn by TouchGFX, this will never be the case, so a transfer is started. If another block is drawn while the DSI transfer is still running, the block will be kept in the "ready to transfer state", and drawing will continue in another free block if possible.'),Object(i.b)("p",null,"When a DSI transfer is complete, we must first free the transferred block, as it now can be reused for another rectangle, and then check to see if the next block is ready for transfer. This is all done in the ER interrupt:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cpp"}),"__irq void DSI_IRQHandler(void) {\n  if (__HAL_DSI_GET_FLAG(&hdsi, DSI_IT_ER))\n  {\n    // End-of-refresh interrupt. Meaning last DSI transfer is complete\n    __HAL_DSI_CLEAR_FLAG(&hdsi, DSI_IT_ER);\n    if (dsiIsTransferring)\n    {\n      HAL::getInstance()->getFrameBufferAllocator()\n                        ->freeBlockAfterTransfer();\n      dsiIsTransferring = 0;\n    }\n    sendBlock();\n  }\n")),Object(i.b)("p",null,"The function sendBlock is more complicated. Here we configure the LTDC and DSI peripherals to transfer the framebuffer. We also configure the display to put the transferred data into the correct place in the display memory. This part of the code will is dependent on the specific display. Check the display datasheet for the command specification."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cpp"}),"static void sendBlock()\n{\n    FrameBufferAllocator* fbAllocator = HAL::getInstance()->getFrameBufferAllocator();\n\n    if (fbAllocator->hasBlockReadyForTransfer())\n    {\n        Rect transfer_rect;\n        const uint8_t* src = fbAllocator->getBlockForTransfer(transfer_rect);\n        dsiIsTransferring = 1;\n\n        //1. setup LTDC and layer address and dimension\n        //2. configure display active area\n        //3. start DSI\n        //4. free block\n\n        __HAL_DSI_WRAPPER_DISABLE(&hdsi);\n\n        LTDC_Layer1->CFBAR = (uint32_t)src;\n\n        const uint32_t width = transfer_rect.width;\n        const uint32_t height = transfer_rect.height;\n\n        LTDC->AWCR = ((width + 1) << 16) | (height + 1);\n        LTDC->TWCR = ((width + 1 + 1) << 16) | (height + 1 + 1);\n\n        const uint16_t layer_x0 = 2 + 0;\n        const uint16_t layer_x1 = 2 + width - 1;\n        LTDC_Layer1->WHPCR = (layer_x1 << 16) | layer_x0;\n\n        const uint16_t layer_y0 = 2 + 0;\n        const uint16_t layer_y1 = 2 + height - 1;\n        LTDC_Layer1->WVPCR = (layer_y1 << 16) | layer_y0;\n\n        LTDC_Layer1->CFBLR = ((width * 3) << 16) | (width * 3 + 3);\n        LTDC_Layer1->CFBLNR = height;\n\n        LTDC->SRCR = (uint32_t)LTDC_SRCR_IMR;\n\n        //2:\n        const int16_t x = transfer_rect.x + 4;\n        const int16_t x2 = transfer_rect.x + 4 + width - 1;\n        uint8_t InitParam1[4] = { (uint8_t)(x >> 8), (uint8_t)(x & 0xFF), (uint8_t)(x2 >> 8), (uint8_t)(x2 & 0xFF)};\n        HAL_DSI_LongWrite(&hdsi, 0, DSI_DCS_LONG_PKT_WRITE, 4, DSI_SET_COLUMN_ADDRESS, InitParam1);\n\n        const int16_t y = transfer_rect.y;\n        const int16_t y2 = transfer_rect.y + height - 1;\n        uint8_t InitParam2[4] = { (uint8_t)(y >> 8), (uint8_t)(y & 0xFF), (uint8_t)(y2 >> 8), (uint8_t)(y2 & 0xFF) };\n        HAL_DSI_LongWrite(&hdsi, 0, DSI_DCS_LONG_PKT_WRITE, 4, DSI_SET_PAGE_ADDRESS, InitParam2);\n\n        //3:\n        __HAL_DSI_WRAPPER_ENABLE(&hdsi);\n        HAL_DSI_Refresh(&hdsi);\n\n        //4:\n        //deallocate is in ER interrupt\n    }\n}\n")),Object(i.b)("h3",{id:"transferring-frame-buffers-on-spi-display"},"Transferring Frame Buffers on SPI Display"),Object(i.b)("p",null,"The STM32G081 has a SPI display. The principle for transferring the rectangles to the display is the same as for the DSI, but some details are different."),Object(i.b)("p",null,"First, when a rectangle is drawn, we start a transfer if none is already in progress:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cpp"}),"void STM32G0HAL::flushFrameBuffer(const touchgfx::Rect& rect)\n{\n    HAL::flushFrameBuffer(rect);\n    frameBufferAllocator->markBlockReadyForTransfer();\n    //start transfer if not running already!\n    if (!LCDManager_IsTransmittingData())\n    {\n        touchgfx::Rect r;\n        const uint8_t* pixels = frameBufferAllocator->getBlockForTransfer(r);\n        LCDManager_SendFrameBufferBlockWithPosition((uint8_t*)pixels, r.x, r.y, r.width, r.height);\n    }\n}\n")),Object(i.b)("p",null,"The function LCDManager_SendFrameBufferBlockWithPosition starts a SPI transfer to the display using DMA."),Object(i.b)("p",null,"The SPI transfer complete handler calls a function when the transfer is complete:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cpp"}),"void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi)\n{\n    UNUSED(hspi);\n    LCD_CS_HIGH();\n    isTransmittingData = 0;\n\n    //Change to SPI datasize to 8 bit from 16 bit\n    heval_Spi.Instance->CR2 &= ~(SPI_DATASIZE_16BIT - SPI_DATASIZE_8BIT);\n\n    //signal transfer complete\n    LCDManager_TransferComplete();\n}\n")),Object(i.b)("p",null,"The LCDManager_TransferComplete functions starts a new transfer:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cpp"}),"void startNewTransfer()\n{\n    FrameBufferAllocator* fba = HAL::getInstance()->getFrameBufferAllocator();\n    fba->freeBlockAfterTransfer();\n    blockIsTransferred = true;\n\n    if (fba->hasBlockReadyForTransfer())\n    {\n        touchgfx::Rect r;\n        const uint8_t* pixels = fba->getBlockForTransfer(r);\n        LCDManager_SendFrameBufferBlockWithPosition((uint8_t*)pixels, r.x, r.y, r.width, r.height);\n    }\n}\n\nvoid LCDManager_TransferComplete()\n{\n    touchgfx::startNewTransfer();\n}\n")),Object(i.b)("h2",{id:"conclusion"},"Conclusion"),Object(i.b)("p",null,"In this article we saw how the partial frame buffer strategy can help lower the memory requirements for platforms that have displays with integrated frame buffer memory."),Object(i.b)("p",null,"The method for configuring and setting up partial framebuffers is the same across all platforms, but the method of sending the content of the blocks to the display varies. We saw how, for an LTDC/DSI based platform (STM32L4R9-DISCO) we were able to reconfigure the LTDC Layer to fit the next block ready for transfer, while on a platform with no LCD controller (STM32G981) we were able to send the blocks to the display using SPI."))}h.isMDXComponent=!0},227:function(e,t,r){"use strict";r.d(t,"a",(function(){return u})),r.d(t,"b",(function(){return b}));var a=r(0),n=r.n(a);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function l(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},i=Object.keys(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var c=n.a.createContext({}),f=function(e){var t=n.a.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):l({},t,{},e)),r},u=function(e){var t=f(e.components);return n.a.createElement(c.Provider,{value:t},e.children)},p="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.a.createElement(n.a.Fragment,{},t)}},m=Object(a.forwardRef)((function(e,t){var r=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=f(r),p=a,m=u["".concat(o,".").concat(p)]||u[p]||h[p]||i;return r?n.a.createElement(m,l({ref:t},c,{components:r})):n.a.createElement(m,l({ref:t},c))}));function b(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=r.length,o=new Array(i);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:a,o[1]=l;for(var c=2;c<i;c++)o[c]=r[c];return n.a.createElement.apply(null,o)}return n.a.createElement.apply(null,r)}m.displayName="MDXCreateElement"},229:function(e,t,r){"use strict";var a=r(5),n=r(0),i=r.n(n),o=function(e){function t(){return e.apply(this,arguments)||this}return Object(a.a)(t,e),t.prototype.render=function(){var e=this.props.noShadow||!1,t=this.props.width,r=this.props.height;return e?i.a.createElement("div",{class:"figure noshadow"},i.a.createElement("a",{href:this.props.imageSource,target:"_blank"},i.a.createElement("img",{width:t,height:r,src:this.props.imageSource})),i.a.createElement("p",null,this.props.caption)):i.a.createElement("div",{class:"figure"},i.a.createElement("a",{href:this.props.imageSource,target:"_blank"},i.a.createElement("img",{width:t,height:r,src:this.props.imageSource})),i.a.createElement("p",null,this.props.caption))},t}(n.Component);t.a=o},230:function(e,t,r){"use strict";var a=r(1),n=r(0),i=r.n(n),o=r(34),l=/^\/(?!\/)/;t.a=function(e){var t,r=e.to,s=e.href,c=r||s,f=l.test(c),u=Object(n.useRef)(!1),p="undefined"!=typeof window&&"IntersectionObserver"in window;return Object(n.useEffect)((function(){return!p&&f&&window.docusaurus.prefetch(c),function(){p&&t&&t.disconnect()}}),[c,p,f]),c&&f?i.a.createElement(o.b,Object(a.a)({},e,{onMouseEnter:function(){u.current||(window.docusaurus.preload(c),u.current=!0)},innerRef:function(e){var r,a;p&&e&&f&&(r=e,a=function(){window.docusaurus.prefetch(c)},(t=new window.IntersectionObserver((function(e){e.forEach((function(e){r===e.target&&(e.isIntersecting||e.intersectionRatio>0)&&(t.unobserve(r),t.disconnect(),a())}))}))).observe(r))},to:c})):i.a.createElement("a",Object(a.a)({},e,{href:c}))}},232:function(e,t,r){"use strict";var a=r(5),n=r(0),i=r.n(n),o=function(e){function t(){return e.apply(this,arguments)||this}return Object(a.a)(t,e),t.prototype.render=function(){return i.a.createElement("code",null,this.props.text)},t}(n.Component);t.a=o},234:function(e,t,r){"use strict";var a=r(5),n=r(0),i=r.n(n),o=function(e){function t(){return e.apply(this,arguments)||this}return Object(a.a)(t,e),t.prototype.render=function(){return i.a.createElement("div",{class:"code-header"},i.a.createElement("div",null,i.a.createElement("h5",null,this.props.children)))},t}(n.Component);t.a=o},266:function(e,t,r){"use strict";var a=r(5),n=r(0),i=r.n(n),o=function(e){function t(){return e.apply(this,arguments)||this}return Object(a.a)(t,e),t.prototype.render=function(){return i.a.createElement("p",null,i.a.createElement("div",{class:"videoWrapper"},i.a.createElement("video",{controls:!0},i.a.createElement("source",{src:this.props.url,type:"video/mp4"}))))},t}(n.Component);t.a=o}}]);