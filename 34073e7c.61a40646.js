(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{153:function(e,a,t){"use strict";t.r(a),t.d(a,"frontMatter",(function(){return l})),t.d(a,"metadata",(function(){return m})),t.d(a,"rightToc",(function(){return c})),t.d(a,"default",(function(){return h}));var n=t(1),o=t(9),r=(t(0),t(244)),i=t(245),s=t(258),l={id:"hardware-selection-external-memories",title:"External Memories"},m={id:"Development/HardwareSelection/HardwareComponents/hardware-selection-external-memories",title:"External Memories",description:"import Figure from '@site/components/Figure';\r",source:"@site/docs\\Development\\HardwareSelection\\HardwareComponents\\external-memories.mdx",permalink:"/docs/Development/HardwareSelection/HardwareComponents/hardware-selection-external-memories",sidebar:"docs",previous:{title:"Display",permalink:"/docs/Development/HardwareSelection/HardwareComponents/hardware-selection-display"},next:{title:"Introduction",permalink:"/docs/Development/BoardBringUp/BoardIntroduction"}},c=[{value:"External non-volatile memories",id:"external-non-volatile-memories",children:[{value:"NOR flash",id:"nor-flash",children:[]},{value:"NAND flash memories",id:"nand-flash-memories",children:[]},{value:"eMMC memories",id:"emmc-memories",children:[]}]},{value:"Volatile memories",id:"volatile-memories",children:[]}],d={rightToc:c},p="wrapper";function h(e){var a=e.components,t=Object(o.a)(e,["components"]);return Object(r.b)(p,Object(n.a)({},d,t,{components:a,mdxType:"MDXLayout"}),Object(r.b)("p",null,"This chapter is focussing on helping you choose the external memory for your embedded graphical user interface.",Object(r.b)("br",{parentName:"p"}),"\n","Before reading this chapter, its is recommended to read the ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"/docs/Development/HardwareSelection/preliminary-considerations"}),"Preliminary Considerations"),"\nand ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"/docs/Development/HardwareSelection/HardwareComponents/hardware-selection-mcu"}),"MCU"),"\nso you are aware of some dependencies which are important when choosing the right external memories."),Object(r.b)("p",null,"Running a TouchGFX GUI application sometimes require external memories for storing the framebuffer(s), bitmaps, fonts, etc.\nA TouchGFX GUI is not dependent on external memories to run, but needs either internal RAM (in MCU) or external RAM for storing the framebuffer(s), and internal and/or external flash for storing data."),Object(r.b)("p",null,"Below overview shows some external memories which can be used with an STM32 MCU, some of the different memory examples are available with both serial and parallel interfaces."),Object(r.b)(i.a,{imageSource:"/img/Development/HardwareSelection/external-memories/memory-overview.png",caption:"Memory overview",mdxType:"Figure"}),Object(r.b)("p",null,"The different STM32 microcontrollers comes with different external memory interfaces, allowing to connect different external memories. "),Object(r.b)("h2",{id:"external-non-volatile-memories"},"External non-volatile memories"),Object(r.b)("p",null,"In a GUI application, the non-volatile storage (flash) is mainly used for storing all bitmaps/data, or for code execution for the STM32 value line products for example.\nThe non-volatile memories are supported by the STM32 products and can be connected with different types of interfaces.\nParallel or serial memories and different configurations, a wide of range of the non-volatile memories are proposed"),Object(r.b)(i.a,{imageSource:"/img/Development/HardwareSelection/external-memories/non-volatile-memory-overview.png",caption:"",noShadow:!0,width:"500",mdxType:"Figure"}),Object(r.b)("p",null,"The choose of the non-volatile storage depend on:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"The type of the interface (Parallel/Serial)"),Object(r.b)("li",{parentName:"ul"},"The performance"),Object(r.b)("li",{parentName:"ul"},"The mode (memory mapped or indirect mode)"),Object(r.b)("li",{parentName:"ul"},"the number of needed pins"),Object(r.b)("li",{parentName:"ul"},"the cost")),Object(r.b)("h3",{id:"nor-flash"},"NOR flash"),Object(r.b)("p",null,"NOR flash memory is one of the most popular storages in embedded systems.\nThe NOR flash is a non-volatilily memory that allows the random access to any area in the memory."),Object(r.b)("p",null,"The NOR flash in ",Object(r.b)("strong",{parentName:"p"}," memory mapped ")," mode where the external flash is seen as an internal memory for read operations.\nThis mode allows the system masters (such as DMA, LTDC, DMA2D, GFXMMU or SDMMC) to access autonomously even in low-power mode when the CPU is\nstopped, which is ideal for mobile and wearable applications."),Object(r.b)("p",null,"Compared to the indirect mode (The non memory mapped mode), the memory mapped mode ..."),Object(r.b)("p",null,"The NOR flash memory is available with wide of range with different configurations:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Parallel NOR flash"),Object(r.b)("li",{parentName:"ul"},"Serial NOR flash"),Object(r.b)("li",{parentName:"ul"},"single, dual, quad and Octo lines for serial memories")),Object(r.b)("h4",{id:"serial-nor-flash-memories"},"Serial NOR flash memories"),Object(r.b)("p",null,"The spi flash memories are connected to the STM32 by the QSPI interface.\nThis type of memories present many benefits:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Frequency: up to 133MHz"),Object(r.b)("li",{parentName:"ul"},"Reducing the printed circuit board (PCB) area"),Object(r.b)("li",{parentName:"ul"},"simplifying the printed circuit board (PCB) design and reducing the GPIOs (general-purposeinput/output) usage "),Object(r.b)("li",{parentName:"ul"},"memory mapped mode up to ",Object(r.b)("strong",{parentName:"li"}," 256Mbytes ")," of adressable area."),Object(r.b)("li",{parentName:"ul"},"number of needed pins is between ",Object(r.b)("strong",{parentName:"li"}," 4 ")," to ",Object(r.b)("strong",{parentName:"li"}," 12 ")," pins. ")),Object(r.b)("h5",{id:"nor-single-dual-quad-octo-flash-memories"},"NOR single, dual, quad, Octo flash memories"),Object(r.b)("p",null,"In the Quad-SPI mode six pins are used: four pins for data and two pins for clock and chip\nselect. In this hardware configuration it is possible to use either Single or Dual-SPI mode.\nIn Quad-SPI mode the data is transferred, received or both over four lines."),Object(r.b)("p",null,"In Dual-SPI mode the hardware configuration is similar to the one in single mode, but here\ntwo lines are used for data, it means that data is sent and received in two lines. As for\nSingle-SPI mode, the IO2 and IO3 lines are optional, if not used the nWP and nHOLD\ndevice pins have to be connected respectively to VDD and VSS."),Object(r.b)("p",null,"Thanks to the Octo-SPI memory-mapped mode, the external memory can be accessed as if\nit was an internal memory allowing the system masters (such as DMA, LTDC, DMA2D,\nGFXMMU or SDMMC) to access autonomously even in low-power mode when the CPU is\nstopped, which is ideal for mobile and wearable applications"),Object(r.b)("p",null,"Below, an overview of the different spi memories depending on the number of data lines:"),Object(r.b)(i.a,{imageSource:"/img/Development/HardwareSelection/external-memories/serial-modes.png",caption:"",noShadow:!0,width:"500",mdxType:"Figure"}),Object(r.b)("h4",{id:"parallel-nor-flash-memories"},"Parallel NOR flash memories"),Object(r.b)("p",null,"The same advantages as the serial flash memory in term of performance and configuration.\nThe parallel NOR flash can be configured in memory mapped mode and can be accessed as if it was an internal memory.\nBy the way, the differences between the parallel and serial NOR flash is the number of pins and the complexity of the printed circuit board (PCB)"),Object(r.b)("p",null,"Up to ",Object(r.b)("strong",{parentName:"p"}," 47 pins ")," are needed for tha NAND flash memory with up to 24 pins for address and 16 pins for data."),Object(r.b)("h3",{id:"nand-flash-memories"},"NAND flash memories"),Object(r.b)("p",null,"The NAND flash memories is ideal for applications such as data storage where ",Object(r.b)("strong",{parentName:"p"}," higher memory capacity ")," and ",Object(r.b)("strong",{parentName:"p"}," faster write and erase operations ")," are required\nThe NAND flashs memories can't be configured as a memory mapped mode and in concequence, the NAND flash memories are ",Object(r.b)("strong",{parentName:"p"}," not recommanded for code execution. ")),Object(r.b)("p",null,"Compared to NOR flash memories, the NAND flash memories have a ",Object(r.b)("strong",{parentName:"p"}," lower cost ")," but more needed GPIOs compared to serial NOR flash memories.\nUp to ",Object(r.b)("strong",{parentName:"p"}," 21 pins ")," are needed for tha NAND flash memory with 16 or 8 pins for data."),Object(r.b)(i.a,{imageSource:"/img/Development/HardwareSelection/external-memories/NAND.png",caption:"",noShadow:!0,width:"500",mdxType:"Figure"}),Object(r.b)("h3",{id:"emmc-memories"},"eMMC memories"),Object(r.b)("p",null,"==> To Be verified"),Object(r.b)("p",null,"eMMC (Embedded MulTI Media Card), established by the MMC Association, is a standard specification of embedded memory for products such as mobile phones or tablets. eMMC is equivalent to NAND flash plus master IC, and similar to SD or TF card in external interface protocol. One obvious advantage of eMMC is the integration of a controller in the package that provides standard interfaces and manages flash memory, allowing handset manufacturers to concentrate on other parts of product development and shorten the time to launch products to the market. These characteristics are equally important for NAND vendors who want to reduce lithography size and cost."),Object(r.b)("p",null,"eMMC consists of an embedded storage solution with an MMC (Multimedia Card) interface, a flash memory device, and a master controller, all in a small BGA package. eMMC has fast and upgradeable performance, whose interface speeds is up to 52 M Bytes per second and interface voltage can be 1.8v or 3.3v."),Object(r.b)("p",null,"Up to ",Object(r.b)("strong",{parentName:"p"}," 10 pins ")," are needed for tha eMMC flash memory with 8 pins for data."),Object(r.b)(i.a,{imageSource:"/img/Development/HardwareSelection/external-memories/eMMC.png",caption:"",noShadow:!0,width:"500",mdxType:"Figure"}),Object(r.b)("h2",{id:"volatile-memories"},"Volatile memories"),Object(r.b)("p",null,'External Volatile memory is mainly used for storing the framebuffer(s), if the internal RAM is insufficient. This section is focussing on SRAM, DRAM and PSRAM as they are commonly used in embedded systems running a GUI. But here are other available variants, and the memory manufactures are using different naming schemes for their memories for example "hyper RAM", "IoT RAM", "octal RAM", and common for most of them is you can find an STM32 MCU which supports it.  '),Object(r.b)(i.a,{imageSource:"/img/Development/HardwareSelection/external-memories/volatile-memory-overview.png",caption:"Volatile Memories",mdxType:"Figure"}),Object(r.b)("p",null,"When selecting the right external RAM, we recommend having the following in mind:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Density "),Object(r.b)("li",{parentName:"ul"},"Performance"),Object(r.b)("li",{parentName:"ul"},"Power consumption"),Object(r.b)("li",{parentName:"ul"},"Interface / pin size"),Object(r.b)("li",{parentName:"ul"},"Framebuffer strategy")),Object(r.b)("h4",{id:"sram"},"SRAM"),Object(r.b)("p",null,"SRAM is a static random-access memory and is retaining the bit data as long as the power is supplied. Generally SRAM provides faster access, but can be more expensive than DRAM. It comes in smaller densities like 64 Kbits to 32 Mbits.\nSRAM typically has a lower access time compared to DRAM and therefor more suitable for GUIs needing more animations, scaling, rotation etc.\nSRAM comes in both synchronous and asynchronous modes, where as the synchronous modes offers higher bandwidth capabilities, but also a more complex interface."),Object(r.b)("p",null,"Note. "),Object(r.b)(s.a,{mdxType:"Note"},"Also available as a non-volatile random-access memory called nvSRAM which also has the ability to store and recall data."),Object(r.b)("h4",{id:"sdram"},"SDRAM"),Object(r.b)("p",null,"SDRAM is a dynamic random-access memory and stores each bit of data on capacitors, which requires less physical space to store the same amount of data compared to SRAM (Static RAM). As it requires constantly refresh in order to keep the data, it requires more power compared to SRAM.\nSDRAM densities typically comes in 16 Mbits up to 512 Mbits, available in x8, x16, and 32 bit interfaces, running frequencies between 100-200 MHz.\nA suitable SDRAM for storing two framebuffers running a 24bpp 800*480 resolution would be a a 32 Mbits SDRAM as a double framebuffer strategy requires ~24Mbits of RAM. "),Object(r.b)("h4",{id:"psram"},"PSRAM"),Object(r.b)("p",null,"PSRAM is pseudo static random access memory, with an internal structure of a DRAM (control logic), and a SRAM interface. It typically comes in 8-256 Mbits densities. PSRAM compared to traditional SDRAM and SRAM has the advantages of higher speed and lower power consumption."),Object(r.b)("p",null,"New octal RAM and Hyper RAM memories uses serial 8 bit interfaces in a dual data rate mode, offering high throughput speed and good integration."))}h.isMDXComponent=!0},258:function(e,a,t){"use strict";var n=t(5),o=t(0),r=t.n(o),i=t(256),s=r.a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},r.a.createElement("path",{"fill-rule":"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})),l=function(e){function a(){return e.apply(this,arguments)||this}return Object(n.a)(a,e),a.prototype.render=function(){return r.a.createElement(i.a,{color:"var(--highlight-color-note)",header:"Note",type:"note",icon:s},this.props.children)},a}(o.Component);a.a=l}}]);