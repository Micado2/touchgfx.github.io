(window.webpackJsonp=window.webpackJsonp||[]).push([[91],{223:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return c})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return h}));var r=n(1),a=n(9),i=(n(0),n(261)),o=n(262),c=(n(272),n(274),n(276),n(273),{id:"scenarios-spi",title:"SPI"}),s={id:"development/touchgfx-hal-development/scenarios/scenarios-spi",title:"SPI",description:"import Figure from '@site/components/Figure';\r",source:"@site/docs\\development\\touchgfx-hal-development\\scenarios\\scenarios-spi.mdx",permalink:"/docs/development/touchgfx-hal-development/scenarios/scenarios-spi"},l=[{value:"Transfering the framebuffer",id:"transfering-the-framebuffer",children:[]},{value:"Returning from flushFrameBuffer",id:"returning-from-flushframebuffer",children:[]}],p={rightToc:l},u="wrapper";function h(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(i.b)(u,Object(r.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,'The following scenario shows, generally, the steps involved in creating a TouchGFX driver when selecting "Custom" display interface in the TouchGFX generator using SPI. The steps involved are similar to that of other display interfaces where the MCU lacks an embedded display controller, e.g. through FMC over an Intel 8080 interface.'),Object(i.b)("p",null,'Once the SPI peripheral is configured in CubeMX the TouchGFX Generator can be used to generate a HAL, using a "custom" display interface, that allows developers to transfer the updated parts of the framebuffer to a connected display using a proprietary driver that developers write themselves. Figure X shows a TouchGFX Generator configuration in which selecting Custom display interface will allow the generated code to support the transfer of the updated parts of the framebuffer to the display.'),Object(i.b)(o.a,{imageSource:"/img/development/touchgfx-hal-development/scenarios/custom-interface.png",caption:"Project activity",noShadow:!0,mdxType:"Figure"}),Object(i.b)("p",null,"Generally, for displays with embedded GRAM such as 8080 or SPI displays, the driver is structured as follows:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},'Based on area of the framebuffer to be redrawn, move the "display cursor" to a place in GRAM that matches this.'),Object(i.b)("li",{parentName:"ol"},"Prepare to write incoming pixel data to GRAM."),Object(i.b)("li",{parentName:"ol"},"Send pixel data.")),Object(i.b)("h2",{id:"transfering-the-framebuffer"},"Transfering the framebuffer"),Object(i.b)("p",null,"When an area of the framebuffer has been updated, the TouchGFX Engine will call ",Object(i.b)("inlineCode",{parentName:"p"},"HAL::flushFrameBuffer"),"."),Object(i.b)("p",null,"React to signal (S?) from TouchGFX Engine."),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-cpp"}),"void  TouchGFXHAL::flushFrameBuffer(const Rect& rect)\n{\n    /* Set Cursor */\n    __ST7789H2_SetDisplayWindow(rect.x, rect.y, rect.width, rect.height);\n\n    /* Prepare to write to LCD RAM */\n    ST7789H2_WriteReg(ST7789H2_WRITE_RAM, (uint8_t*)NULL, 0);\n\n    /* Send Pixels */\n    this->copyFrameBufferBlockToLCD(rect);\n}\n")),Object(i.b)("p",null,"The following function ",Object(i.b)("inlineCode",{parentName:"p"},"__ST7789H2_SetDisplayWindow")," sets the ",Object(i.b)("inlineCode",{parentName:"p"},"x")," and ",Object(i.b)("inlineCode",{parentName:"p"},"y"),' coordinates for the virtual "cursor" in GRAM by writing to specific registers, which is usual for displays using GRAM.'),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-c"}),'extern "C"\nvoid __ST7789H2_SetDisplayWindow(uint16_t Xpos, uint16_t Ypos, uint16_t Width, uint16_t Height)\n{\n    uint8_t   parameter[4];\n\n    /* CASET: Column Addrses Set */\n    parameter[0] = 0x00;\n    parameter[1] = Xpos;\n    parameter[2] = 0x00;\n    parameter[3] = Xpos + Width - 1;\n    ST7789H2_WriteReg(ST7789H2_CASET, parameter, 4);\n\n    /* RASET: Row Addrses Set */\n    parameter[0] = 0x00;\n    parameter[1] = Ypos;\n    parameter[2] = 0x00;\n    parameter[3] = Ypos + Height - 1;\n    ST7789H2_WriteReg(ST7789H2_RASET, parameter, 4);\n}\n')),Object(i.b)("p",null,"The following function ",Object(i.b)("inlineCode",{parentName:"p"},"TouchGFXHAL::copyFrameBufferBlockToLCD")," is a private function that sends one line of the updated area (",Object(i.b)("inlineCode",{parentName:"p"},"Rect"),") at a time, ensuring to progress the framebuffer pointer accordingly."),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-cpp"}),"void TouchGFXHAL::copyFrameBufferBlockToLCD(const Rect rect)\n{\n    __IO uint16_t* ptr;\n    uint32_t height;\n\n    // Use default implementation (CPU copy!).\n    // This can be accelerated using regular DMA hardware\n    for (height = 0; height < rect.height ; height++)\n    {\n        ptr = getClientFrameBuffer() + rect.x + (height + rect.y)  * BSP_LCD_GetXSize();\n        LCD_IO_WriteMultipleData((uint16_t*)ptr, rect.width);\n    }\n}\n")),Object(i.b)("h2",{id:"returning-from-flushframebuffer"},"Returning from flushFrameBuffer"),Object(i.b)("p",null,"Once the function returns, TouchGFX Engine returns to its. If developers desire to use DMA to perform these transfers, then they must ensure that ",Object(i.b)("inlineCode",{parentName:"p"},"HAL::flushFrameBuffer(Rect& rect)")," does not return by waiting on a semaphore that is signaled by a DMA Completed interrupt."))}h.isMDXComponent=!0},272:function(e,t,n){"use strict";var r=n(5),a=n(0),i=n.n(a),o=n(265),c=i.a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},i.a.createElement("path",{"fill-rule":"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})),s=function(e){function t(){return e.apply(this,arguments)||this}return Object(r.a)(t,e),t.prototype.render=function(){return i.a.createElement(o.a,{color:"var(--highlight-color-note)",header:"Note",type:"note",icon:c},this.props.children)},t}(a.Component);t.a=s},276:function(e,t,n){"use strict";var r=n(5),a=n(0),i=n.n(a),o=n(265),c=i.a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},i.a.createElement("path",{"fill-rule":"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})),s=function(e){function t(){return e.apply(this,arguments)||this}return Object(r.a)(t,e),t.prototype.render=function(){return i.a.createElement(o.a,{color:"var(--highlight-color-try)",header:"Things to try",type:"try",icon:c},this.props.children)},t}(a.Component);t.a=s}}]);