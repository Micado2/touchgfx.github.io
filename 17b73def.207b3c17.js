(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{132:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return c})),a.d(t,"metadata",(function(){return l})),a.d(t,"rightToc",(function(){return h})),a.d(t,"default",(function(){return p}));var n=a(1),r=a(9),i=(a(0),a(209)),o=(a(214),a(211)),s=a(213),c=(a(212),{id:"GeneralUIComponentPerformance",title:"General UI Component Performance"}),l={id:"Development/UIDevelopment/UIComponents/GeneralUIComponentPerformance",title:"General UI Component Performance",description:"import Figure from '@site/components/Figure';",source:"@site/docs\\Development\\UIDevelopment\\UIComponents\\GeneralUIComponentPerformance.mdx",permalink:"/docs/Development/UIDevelopment/UIComponents/GeneralUIComponentPerformance",sidebar:"docs",previous:{title:"DigitalClock",permalink:"/docs/Development/UIDevelopment/UIComponents/Miscellaneous/DigitalClock"},next:{title:"Loading Images at Runtime",permalink:"/docs/Development/UIDevelopment/Scenarios/LoadingImages"}},h=[{value:"Image Drawing",id:"image-drawing",children:[{value:"Hardware support for data copy",id:"hardware-support-for-data-copy",children:[]},{value:"Image format",id:"image-format",children:[]},{value:"Access to the Image data",id:"access-to-the-image-data",children:[]},{value:"Access to the framebuffer",id:"access-to-the-framebuffer",children:[]},{value:"Image resolution",id:"image-resolution",children:[]},{value:"Transparency",id:"transparency",children:[]}]},{value:"MCU Drawing",id:"mcu-drawing",children:[]},{value:"Canvas Widgets",id:"canvas-widgets",children:[]},{value:"Texts",id:"texts",children:[]}],d={rightToc:h},m="wrapper";function p(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(i.b)(m,Object(n.a)({},d,a,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"This section describes the performance of general TouchGFX rendering operations used by most UI components."),Object(i.b)("h2",{id:"image-drawing"},"Image Drawing"),Object(i.b)("p",null,"Image drawing is one of the most essential drawing operations in TouchGFX, as almost all UI components to some extent rely on drawing one or more images. Your systems ability to draw images in a fast and effective way is therefore often very important. There are a lot of factors that influence the performance of image drawing. However, on almost all hardware setups TouchGFX image drawing is considered a fast operation compared to other drawing operations."),Object(i.b)("h3",{id:"hardware-support-for-data-copy"},"Hardware support for data copy"),Object(i.b)("p",null,"TouchGFX stores the image data uncompressed in the selected image format (e.g. RGB565, L8, ARGB8888). The advantage of the uncompressed format is that it allows TouchGFX, in most cases, to use the image directly and transfer it unmodified to the framebuffer. If the MCU has a DMA, this can and should be used for the memory copy, as this speeds up the transfer and minimizes the MCU load."),Object(i.b)("p",null,"One limitation to this approach is if the image format includes an alpha channel. Here a normal DMA transfer cannot be used since the MCU needs to perform a pixel blending of the image data with framebuffer pixels. However, if you are using an STM32 with graphics acceleration like ChromART / DMA2D, you can utilize the DMA for these types of images as well. Here the DMA is not only capable copying data, but actually do a copy and blending operation in one go, thereby improving speed and lowering the MCU load considerably."),Object(i.b)("h3",{id:"image-format"},"Image format"),Object(i.b)("p",null,"The image format has an impact on the image drawing performance as well, depending on the hardware support you have. A rule of thumb is that the less data you have to transfer, the faster you can do it. So transfering an RGB565 image compared to a similar RGB888 will be faster in most cases, since an RGB565 image is two thirds the size of the equivalent RGB888 image."),Object(i.b)("h3",{id:"access-to-the-image-data"},"Access to the Image data"),Object(i.b)("p",null,"The time needed to the access the image data is very important, since this will be accessed each time the image is rendered. The image data can be stored in different hardware locations, with different access times, in a TouchGFX application."),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("strong",{parentName:"th"},"Image data location")),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("strong",{parentName:"th"},"Description")))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("strong",{parentName:"td"},"External Flash")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"The advantage of external flash is its low cost and the size, which is often quite large, allowing you to have a lot of images in your application. However, access time varies a lot, but choosing QSPI or alternatives like it, will give you a high throughput, resulting in a significant boost to the image drawing performance.")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("strong",{parentName:"td"},"External RAM")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"In some cases you might need to cache your images in External RAM. This is often the case when you are forced to use non-memory mapped flash (e.g. NAND, EMMC) which cannot be used directly for image rendering in TouchGFX. In this case the access to the external RAM is essential for the performance of image drawing in your application.")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("strong",{parentName:"td"},"Internal Flash")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"In some cases you can store some or all or your images in internal flash, even though the storage space here is very limited. Access is very fast, so if you have some images that are essential for an animation and performance is an issue (e.g. if it is used by a TextureMapper) it might be worth trying to store it in internal flash if possible.")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("strong",{parentName:"td"},"Internal RAM")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"In very rare cases you will render images from the internal RAM. The storage space is very limited but the access time is very fast, so images stored here (using caching) will be rendered very fast.")))),Object(i.b)("h3",{id:"access-to-the-framebuffer"},"Access to the framebuffer"),Object(i.b)("p",null,"Rendering an image will always end up in an update of the framebuffer. If the image includes an alpha channel, you will not only write, but also read pixel data in the framebuffer to perform the actual blending. Therefore, the read/write access time to the RAM you are using for storing the framebuffer, is key to have a good image drawing performance."),Object(i.b)("h3",{id:"image-resolution"},"Image resolution"),Object(i.b)("p",null,"Since the data that needs to be transfered is proportional to the resolution of the image, the image resolution naturally has an effect on the image drawing operation."),Object(i.b)("h3",{id:"transparency"},"Transparency"),Object(i.b)("p",null,"The opacity of an image has an effect on the rendering time for an image. An image with alpha, will have a longer rendering time than an image without, due to the fact that it will have to be blended with the framebuffer. Therefore a blending operation has to read from the framebuffer, whereas a solid image can simply overwrite data in the framebuffer. This is the case even if you have hardware acceleration. The ratio between rendering solid and semi-transparent images may, however, vary from one setup to another."),Object(i.b)("h2",{id:"mcu-drawing"},"MCU Drawing"),Object(i.b)("p",null,"Some widgets rely on direct framebuffer manipulation. This approach performs one or more calculations for each pixel in the invalidated area, and updates the pixel in the framebuffer. This is a rather slow operation, especially if the calculation for each pixel is complex."),Object(i.b)("p",null,"The MCU processing power is essential if your MCU drawing is performing a lot of calcuations. Access to the framebuffer (access to either internal or external RAM) will also have an impact since writing (and possible reading) the framebuffer data is done per pixel in the invalidated area."),Object(i.b)("h2",{id:"canvas-widgets"},"Canvas Widgets"),Object(i.b)("p",null,Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"/docs/Development/UIDevelopment/TouchGFXEngineFeatures/CanvasWidgets"}),"Canvas widgets")," are a special type of TouchGFX widgets used for drawing anti-aliased geometric shapes. They are typically quite complex and thus fairly slow to render."),Object(i.b)("p",null,"The rendering time is linear to the size of the invalidated part of the geometric shape."),Object(i.b)("p",null,"Canvas widgets requires a memory block to store intermediate calcuation results. The size and performance impact of this is described in the ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"/docs/Development/UIDevelopment/TouchGFXEngineFeatures/CanvasWidgets"}),"canvas widgets article"),"."),Object(i.b)(o.a,{mdxType:"Tip"},"Most of the TouchGFX standard Canvas Widgets, like circle, have update methods that will only invalidate the changed part of the widget. So if you are updating the start Like for example ",Object(i.b)(s.a,{text:"circle::updateArc(...)",mdxType:"InlineCode"}),", which will not invalidate the entire circle but only the changed part. Be sure to use these kind of operations for optimal performance."),Object(i.b)("h2",{id:"texts"},"Texts"),Object(i.b)("p",null,"Text rendering depends on image drawing, as all the used characters are transformed into images as described in the ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"####TODO_link_to_text_article"}),"text article"),". The images are in A4 format which is basically a 4 bit alpha value for each of the pixels in the image. If you apply a color to this pattern, you will have an anti-aliased image of a character."),Object(i.b)("p",null,"Since text rendering is a set of image drawing operations, one for each character, the performance characteristics for image drawing applies to text rendering as well, including performance improvements using hardware acceleration like ChromART / DMA2D."))}p.isMDXComponent=!0},211:function(e,t,a){"use strict";var n=a(5),r=a(0),i=a.n(r),o=a(208),s=i.a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},i.a.createElement("path",{"fill-rule":"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"})),c=function(e){function t(){return e.apply(this,arguments)||this}return Object(n.a)(t,e),t.prototype.render=function(){return i.a.createElement(o.a,{color:"var(--highlight-color-tip)",header:"Tip",type:"tip",icon:s},this.props.children)},t}(r.Component);t.a=c},212:function(e,t,a){"use strict";var n=a(5),r=a(0),i=a.n(r),o=function(e){function t(){return e.apply(this,arguments)||this}return Object(n.a)(t,e),t.prototype.render=function(){return i.a.createElement("i",null,this.props.text)},t}(r.Component);t.a=o},213:function(e,t,a){"use strict";var n=a(5),r=a(0),i=a.n(r),o=function(e){function t(){return e.apply(this,arguments)||this}return Object(n.a)(t,e),t.prototype.render=function(){return i.a.createElement("code",null,this.props.text)},t}(r.Component);t.a=o}}]);