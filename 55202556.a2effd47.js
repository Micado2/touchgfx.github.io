(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{146:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return b})),a.d(t,"metadata",(function(){return c})),a.d(t,"rightToc",(function(){return f})),a.d(t,"default",(function(){return p}));var r=a(1),n=a(9),o=(a(0),a(209)),i=(a(223),a(214)),l=a(210),s=a(220),b={id:"Framebuffer",title:"Framebuffer"},c={id:"BasicConcepts/Framebuffer",title:"Framebuffer",description:"import useBaseUrl from '@docusaurus/useBaseUrl'; ",source:"@site/docs\\BasicConcepts\\Framebuffer.mdx",permalink:"/docs/BasicConcepts/Framebuffer",sidebar:"docs",previous:{title:"Graphics Engine",permalink:"/docs/BasicConcepts/GraphicsEngine"},next:{title:"Hardware Components",permalink:"/docs/BasicConcepts/HardwareComponents"}},f=[{value:"What is a framebuffer",id:"what-is-a-framebuffer",children:[{value:"Colors",id:"colors",children:[]},{value:"Display",id:"display",children:[]}]},{value:"Location of framebuffer",id:"location-of-framebuffer",children:[{value:"Internal RAM",id:"internal-ram",children:[]},{value:"External RAM",id:"external-ram",children:[]},{value:"Display RAM",id:"display-ram",children:[]}]},{value:"Amount of framebuffers",id:"amount-of-framebuffers",children:[{value:"One framebuffer",id:"one-framebuffer",children:[]},{value:"More than one framebuffer",id:"more-than-one-framebuffer",children:[]},{value:"Less than one framebuffer",id:"less-than-one-framebuffer",children:[]}]},{value:"Memory consumption",id:"memory-consumption",children:[]},{value:"TODO",id:"todo",children:[]}],m={rightToc:f},u="wrapper";function p(e){var t=e.components,a=Object(n.a)(e,["components"]);return Object(o.b)(u,Object(r.a)({},m,a,{components:t,mdxType:"MDXLayout"}),Object(o.b)("h2",{id:"what-is-a-framebuffer"},"What is a framebuffer"),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"A framebuffer is a piece of memory that is written by TouchGFX and displayed on the physical display.")),Object(o.b)("p",null,"A framebuffer is a contiguous part of RAM of a given size. "),Object(o.b)(i.a,{imageSource:"/img/BasicConcepts/framebuffer_contiguous_memory.svg",caption:"Framebuffer memory",noShadow:"true",mdxType:"Figure"}),Object(o.b)("p",null,"A framebuffer has an associated width and height.\nTherefore we typically think of a framebuffer as being a two dimensional part of memory, indexable\nby x, y coordinates."),Object(o.b)(i.a,{imageSource:"/img/BasicConcepts/framebuffer_2d_memory.svg",caption:"2D framebuffer memory",noShadow:"true",mdxType:"Figure"}),Object(o.b)("p",null,"A framebuffer has an associated color format.\nEach entry in the framebuffer will be a color in this color format.\nWe will refer to each such entry in the framebuffer as a pixel. "),Object(o.b)("p",null,"We can update the color of a pixel at position x,y in the framebuffer by calculating the memory address\nof the pixel within the framebuffer and updating the stored color."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-cpp"}),"uint32_t pixelAddress = x + y * WIDTH;\nframebuffer[ pixelAddress ] = newColor;\n")),Object(o.b)("p",null,"Similarly we can get the color of a pixel and use this in calculations. For instance darkening the color\nof a pixel in the framebuffer (assuming we have a ",Object(o.b)("inlineCode",{parentName:"p"},"darken")," function available)."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-cpp"}),"uint32_t pixelAddress = x + y * WIDTH;\nframebuffer[ pixelAddress ] = darken( framebuffer[ pixelAddress ] );\n")),Object(o.b)("h3",{id:"colors"},"Colors"),Object(o.b)("p",null,"In TouchGFX the pixel color format of a framebuffer can be either"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"Grayscale")," 1, 2 or 4 bpp grayscale, or"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"High or true color")," 16, 24 or 32 bpp color")),Object(o.b)("p",null,"The more bits per pixels used the more distinct colors can be represented by the framebuffer, moreover\nthe more bits per pixels used the more memory consumed by the framebuffer. "),Object(o.b)("h3",{id:"display"},"Display"),Object(o.b)("p",null,"The contents of the framebuffer is what is ultimately seen on the physical display.\ntransferred"),Object(o.b)(i.a,{imageSource:"/img/BasicConcepts/display_and_framebuffer.svg",caption:"Framebuffer and display",noShadow:"true",mdxType:"Figure"}),Object(o.b)("p",null,"Therefore it is very common to have the same width and height of the framebuffer and the display."),Object(o.b)("p",null,"The overall job of TouchGFX is to continously render its description of the screen\ninto a framebuffer."),Object(o.b)("p",null,"The memory of the framebuffer contains an image. "),Object(o.b)("p",null,"When TouchGFX renders its scene graph into an image"),Object(o.b)("p",null,"TouchGFX renders "),Object(o.b)("p",null,"The contents of a framebuffer is what you see on a physical display"),Object(o.b)("h2",{id:"location-of-framebuffer"},"Location of framebuffer"),Object(o.b)("p",null,"A very oversimplified view of a microcontroller based graphics system is here."),Object(o.b)(i.a,{imageSource:"/img/BasicConcepts/simplified_graphics_system.svg",caption:"Oversimplified view of graphics system",noShadow:!0,mdxType:"Figure"}),Object(o.b)("p",null,"A framebuffer can be placed either internally in the MCU, in external RAM or in memory\nembedded within the display."),Object(o.b)(i.a,{imageSource:"/img/BasicConcepts/framebuffer_placement.svg",caption:"Possible locations of framebuffer",noShadow:"true",mdxType:"Figure"}),Object(o.b)("p",null,"Each possible location has potential benefits and drawbacks."),Object(o.b)("h3",{id:"internal-ram"},"Internal RAM"),Object(o.b)("p",null,"Placing the framebuffer in RAM internal to the MCU makes the read and write access to the framebuffer\nas fast as possible. This means that your TouchGFX application will run as smoothly as possible.\nConversely, internal RAM is a very scarce resource and one that is used by many\nparts of a system, therefore occupying a large part of this with a framebuffer might be infeasible."),Object(o.b)("p",null,"If feasible, having a framebuffer in internal RAM, could reduce the overall cost of the system as\nno additional RAM is needed. "),Object(o.b)("h3",{id:"external-ram"},"External RAM"),Object(o.b)("p",null,"If the system has external RAM, placing the framebuffer here is an alternative to placing it in internal RAM.\nThe read and write access to external RAM will typically be slower than to the internal RAM,\nbut the amount of external RAM will typically be much larger. Therefore this is sometimes the only viable solution."),Object(o.b)("h3",{id:"display-ram"},"Display RAM"),Object(o.b)("p",null,'Depending on the type of display in the system there might be memory embedded on the display.\nThis memory holds the contents of the "physical" pixels of the display.\nThis memory is seldomly memory mapped and is therefore not intended nor suitable for random pixel reads or writes from TouchGFX.\nPlacing a TouchGFX framebuffer in the RAM of the display is not recommended/possible. '),Object(o.b)("h2",{id:"amount-of-framebuffers"},"Amount of framebuffers"),Object(o.b)("p",null,"TouchGFX can use more or less than one framebuffer in the application.\nThe amount of framebuffers impacts the performance and memory consumption of the application."),Object(o.b)("h3",{id:"one-framebuffer"},"One framebuffer"),Object(o.b)("p",null,"One framebuffer is enough to hold all pixels that are to be transferred to the display.\nHaving one framebuffer that "),Object(o.b)("h3",{id:"more-than-one-framebuffer"},"More than one framebuffer"),Object(o.b)("p",null,"Having more than one framebuffer implies that we"),Object(o.b)("p",null,"TODO FIGURE"),Object(o.b)("h3",{id:"less-than-one-framebuffer"},"Less than one framebuffer"),Object(o.b)("p",null,"Having less than one framebuffer implies that"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"less memory is consumed"),Object(o.b)("li",{parentName:"ul"},"more transfers")),Object(o.b)("p",null,"TODO FIGURE"),Object(o.b)("h2",{id:"memory-consumption"},"Memory consumption"),Object(o.b)("p",null,"The amount of colors and the number of pixels in the framebuffer determines\nthe memory consumed by one framebuffer."),Object(o.b)("p",null,"In general the amount of memory used by a framebuffer is\n",Object(o.b)("strong",{parentName:"p"}," width ","*"," height ","*"," color depth in bits / 8 ")," bytes"),Object(o.b)("table",null,Object(o.b)("thead",{parentName:"table"},Object(o.b)("tr",{parentName:"thead"},Object(o.b)("th",Object(r.a)({parentName:"tr"},{align:null}),"Resolution"),Object(o.b)("th",Object(r.a)({parentName:"tr"},{align:null}),"Memory consumed"))),Object(o.b)("tbody",{parentName:"table"},Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(r.a)({parentName:"tr"},{align:null}),"480x272"),Object(o.b)("td",Object(r.a)({parentName:"tr"},{align:null}),"TEXT")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(r.a)({parentName:"tr"},{align:null}),"TEXT"),Object(o.b)("td",Object(r.a)({parentName:"tr"},{align:null}),"TEXT")))),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"}," TODO "),"  make these calculations stand out more."),Object(o.b)("p",null,"A framebuffer of width 800 and height 480 using 16 bpp colors will\nhave 800 * 480 = 384000 pixels."),Object(o.b)("p",null,"The framebuffer therefore consumes\n384000*16bpp = 6144000 bits = 768000 bytes = 750 kb of memory"),Object(o.b)(i.a,{imageSource:"/img/BasicConcepts/display_and_framebuffer.png",caption:"Display and framebuffer",mdxType:"Figure"}),Object(o.b)("p",null,Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"http://www.google.com"}),"LTDC")),Object(o.b)("h2",{id:"todo"},"TODO"),Object(o.b)("p",null,"Types of display\nRefreshed 60 times per second\nRead and write speed of memory, internal, external, gram on display"),Object(o.b)(l.a,{mdxType:"FurtherReading"},Object(o.b)("li",null,"STM32 ",Object(o.b)(s.a,{to:"https://www.st.com/content/ccc/resource/technical/document/application_note/group0/25/ca/f9/b4/ae/fc/4e/1e/DM00287603/files/DM00287603.pdf/jcr:content/translations/en.DM00287603.pdf",mdxType:"Link"},"LTDC")," display controller"),Object(o.b)("li",null,"TODO section on HW components"),Object(o.b)("li",null,"TODO section on drawing/rendering/frame strategy")),Object(o.b)("p",null,"###TODO Write"))}p.isMDXComponent=!0},210:function(e,t,a){"use strict";var r=a(5),n=a(0),o=a.n(n),i=a(208),l=o.a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},o.a.createElement("path",{"fill-rule":"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})),s=function(e){function t(){return e.apply(this,arguments)||this}return Object(r.a)(t,e),t.prototype.render=function(){return o.a.createElement(i.a,{color:"var(--highlight-color-further-reading)",header:"Further reading",type:"further-reading",icon:l},this.props.children)},t}(n.Component);t.a=s}}]);