(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{156:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return u})),n.d(t,"rightToc",(function(){return h})),n.d(t,"default",(function(){return d}));var r=n(1),a=n(9),o=(n(0),n(258)),i=n(259),c=n(272),l=n(267),s={id:"TouchGFXHALDevelopmentGenerator",title:"Generator User Guide"},u={id:"Development/TouchGFXHALDevelopment/TouchGFXHALDevelopmentGenerator",title:"Generator User Guide",description:"import Figure from '@site/components/Figure';",source:"@site/docs\\Development\\TouchGFXHALDevelopment\\touchgfx_generator.mdx",permalink:"/docs/Development/TouchGFXHALDevelopment/TouchGFXHALDevelopmentGenerator",sidebar:"docs",previous:{title:"Abstraction Layer Architecture",permalink:"/docs/Development/TouchGFXHALDevelopment/TouchGFXHALDevelopmentArchitecture"},next:{title:"Introduction",permalink:"/docs/Development/TouchGFXHALDevelopment/scenarios/TouchGFXHALDevelopmentScenariosIntro"}},h=[{value:"Enabling TouchGFX Generator",id:"enabling-touchgfx-generator",children:[]},{value:"Display",id:"display",children:[{value:"Interface and dimensions",id:"interface-and-dimensions",children:[]},{value:"Buffering Strategies",id:"buffering-strategies",children:[]}]},{value:"Driver",id:"driver",children:[{value:"Application Tick Source",id:"application-tick-source",children:[]},{value:"Graphics Accelerator",id:"graphics-accelerator",children:[]},{value:"Real-Time Operating System",id:"real-time-operating-system",children:[]}]},{value:"Generated Code Architecture",id:"generated-code-architecture",children:[]},{value:"Generated project",id:"generated-project",children:[]}],p={rightToc:h},b="wrapper";function d(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(o.b)(b,Object(r.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)(i.a,{imageSource:"/img/Development/TouchGFXHALDevelopment/activities_selected_002.png",caption:"Project activity",noShadow:!0,mdxType:"Figure"}),Object(o.b)("p",null,"The TouchGFX Generator, a part of X-CUBE-TOUCHGFX, is a CubeMX additional-software component that can help developers create the HAL and general configuration for a TouchGFX Application through user input and reading CubeMX configurations."),Object(o.b)("p",null,"Once generated through CubeMX, a partial\xa0TouchGFX project can be opened through the TouchGFX Designer. Further developing the UI and generating source code for application assets and screen definitions will automatically add generated code files to the target project that was set through CubeMX (in the case of the following figure, EWARM)."),Object(o.b)("h2",{id:"enabling-touchgfx-generator"},"Enabling TouchGFX Generator"),Object(o.b)("p",null,'Figure X shows a project with the X-CUBE-TOUCHGFX TouchGFX Generator already enabled. Users can gain access to X-CUBES by pressing "Additional Software".'),Object(o.b)(i.a,{noShadow:!0,imageSource:"/img/Development/TouchGFXHALDevelopment/enable_generator.png",caption:"<Figure X - >",mdxType:"Figure"}),Object(o.b)(i.a,{noShadow:!0,imageSource:"/img/Development/TouchGFXHALDevelopment/add_generator.png",caption:"<Figure X - >",mdxType:"Figure"}),Object(o.b)("p",null,"This section explains how users can configure TouchGFX Generator to generate a TouchGFX HAL that works with the current CubeMX settings of the project."),Object(o.b)("p",null,"Three groups exist in the UI:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("em",{parentName:"li"},"Dependencies")," - This group contains notifications to the developer about dependencies, warnings or concrete errors in the configuration. The group is hidden if no entries exist."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("em",{parentName:"li"},"Display")," - This group contains settings related to display like interface, framebuffer bitdepth, -width and -height. These settings directly impact the size of the canvas of the TouchGFX project as well as the code generated for assets."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("em",{parentName:"li"},"Driver")," -\xa0This group allows the user to opt-in for a number of ready-made drivers related to the tick source of the application, graphics acceleration and RTOS. Since CubeMX offers FreeRTOS (cmsis rtos v1 and v2) TouchGFX Generator provides drivers for each of these options.")),Object(o.b)("h2",{id:"display"},"Display"),Object(o.b)("h3",{id:"interface-and-dimensions"},"Interface and dimensions"),Object(o.b)("p",null,"Multiple display interfaces are usable today with STM32 micro controllers, e.g.:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Parallel RGB"),Object(o.b)("li",{parentName:"ul"},"MIPI DSI"),Object(o.b)("li",{parentName:"ul"},"FMC"),Object(o.b)("li",{parentName:"ul"},"SPI")),Object(o.b)("p",null,"The TouchGFX Generator is not yet capable of properly abstracting DSI, FMC and SPI interfaces using the information available from additional IP configuration in CubeMX and thus it is up to the user to implement these drivers. In the case of LTDC, however, the TouchGFX Generator can supply the driver which is generated and configured automatically."),Object(o.b)(l.a,{mdxType:"FurtherReading"},'See section "Scenarios" for concrete examples of drivers for DSI, FMC and SPI.'),Object(o.b)("h3",{id:"buffering-strategies"},"Buffering Strategies"),Object(o.b)("p",null,"A framebuffer strategy in TouchGFX is a .. Please read the following articles about framebuffers (###TODO). The following frame buffer strategies can be configured through TouchGFX generator:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"Single Buffer"),' - Use only one application frame buffer. Limits performance but uses less memory. Can be used with the "Buffer Location" configuration to place it in internal RAM. For further optimization the user is allowed to define a function that returns the current line being processed by the display controller which is used by the framework to allow updates to memory that has already been transferred to the display during.'),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"Double Buffer")," - Use two frame buffers. Allows for better performance at the cost of memory."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"Partial Buffer")," - Use one or more user defined chunks of memory as the frame buffer. This strategy is targeted at low cost solutions that do not rely on external RAM, but have displays for which a full frame buffer would exceed available memory.")),Object(o.b)("p",null,'In the case of Single- and Double Buffer users are allowed to configure their location through the "Buffer Location" configuration which offers the following options:'),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"By Allocation")," - Lets the linker place frame buffer memory according to linker script. Default is in internal RAM."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"By Address")," - Allows the user to define one (Single) or two (Double) frame buffer addresses.")),Object(o.b)("p",null,"The ",Object(o.b)("strong",{parentName:"p"},"Partial Buffer")," strategy allows the user to define the following parameters:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Number of blocks (always placed in internal ram)"),Object(o.b)("li",{parentName:"ul"},"Block size (bytes)")),Object(o.b)("p",null,"To understand some core concepts regarding the Partial Buffer strategy please read the ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"/docs/Development/UIDevelopment/Scenarios/LoweringMemoryUsageWithPartialFrameBuffer"}),"dedicated article")," on Lowering Memory requirements using partial Frame Buffers. The article shows, conceptually, how to achieve partial frame buffers and the code shown in this article will differ slightly from what is generated by TouchGFX Generator."),Object(o.b)("h2",{id:"driver"},"Driver"),Object(o.b)("p",null,"The driver section allows developers to select drivers for various responsibilities of a TouchGFX HAL."),Object(o.b)("h3",{id:"application-tick-source"},"Application Tick Source"),Object(o.b)("p",null,"The application tick source for an application defines how to drive an application forward. The developer has the following options:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"LTDC"),' - If LTDC is selected as the Interface in the "Display" group the Application Tick Source can be "LTDC". This means that TouchGFX Generator will install a driver function (LTDC interrupt handler) in the TouchGFXGeneratedHAL class that drives the application forward by calling ',Object(o.b)("inlineCode",{parentName:"li"},"OSWrappers::signalVSync()"),"."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"Custom")," - In this case, the developer is required to implement a handler that drives the application forward by calling ",Object(o.b)("inlineCode",{parentName:"li"},"OSWrappers::signalVsync()")," repeatedly.")),Object(o.b)(c.a,{mdxType:"Note"},"For the LTDC driver to work, users must enable the LTDC global interrupt through the LTDC NVIC settings or through Global NVIC settings, and also enable generation of handler code."),Object(o.b)(i.a,{noShadow:!0,imageSource:"/img/Development/TouchGFXHALDevelopment/Generator/nvic_global_interrupt_enable.png",caption:"<Figure X - >",mdxType:"Figure"}),Object(o.b)("h3",{id:"graphics-accelerator"},"Graphics Accelerator"),Object(o.b)("p",null,"The developer has three options when it comes to graphics acceleration:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"None")," - The application uses only the CPU to draw frames."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"ChromART (DMA2D)")," -\xa0The application uses the ChromART chip when possible to move and blend pixels, freeing up CPU cycles. The driver is installed by the TouchGFX Generator and does not require any action from the developer."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"Custom")," - The developer must provide a custom implementation (very rarely needed).")),Object(o.b)("h3",{id:"real-time-operating-system"},"Real-Time Operating System"),Object(o.b)("p",null,"Several options are available from TouchGFX Generator when it comes to RTOS support."),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"No RTOS"),Object(o.b)("li",{parentName:"ul"},"CMSIS V1 and V2"),Object(o.b)("li",{parentName:"ul"},"Custom")),Object(o.b)("p",null,"As described in the Abstraction Layer Architecture the TouchGFX Engine uses the ",Object(o.b)("inlineCode",{parentName:"p"},"OSWrappers")," interface to syncrhonize its Main Loop as well as framebuffer access. The users choice results in generated class that uses relevant primitives. Only in the case of ",Object(o.b)("inlineCode",{parentName:"p"},"Custom")," must developers implement the functions themselves."),Object(o.b)("p",null,"The Touchgfx Main Loop is entered by calling the following function:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-cpp"}),"void\xa0MX_TouchGFX_Process(void);\n")),Object(o.b)("p",null,"Developers are required to call this function in the task handler for the task they intend to run the application. Configuring FreeRTOS through CubeMX is not a requirement as long as the Process function is called by the task handler. The following is an example of how to call the process function in the task handler for the Default task:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-cpp",metastring:"{4}","{4}":!0}),"void\xa0StartDefaultTask(void\xa0*argument)\n{\n\xa0\xa0/*\xa0USER\xa0CODE\xa0BEGIN\xa05\xa0*/\n  MX_TouchGFX_Process();\n\xa0\xa0/*\xa0USER\xa0CODE\xa0END\xa05\xa0*/\xa0\n}\n")),Object(o.b)("p",null,"The process function will call a generated function ",Object(o.b)("inlineCode",{parentName:"p"},"touchgfx_taskEntry()"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-cpp",metastring:"{9}","{9}":!0}),"void touchgfx_taskEntry()\n{\n /*\n * Main event loop. Will wait for OSWrapper::signalVsync() to be called, and then process next frame. Call\n * this function from your GUI task.\n *\n * Note This function never returns\n */\n hal.taskEntry();\n}\n")),Object(o.b)("h2",{id:"generated-code-architecture"},"Generated Code Architecture"),Object(o.b)("p",null,'Before covering more advanced use-cases for the options in each group it is important to understand the architecture of the generated code and how developers can take advantage of it to customize behavior. Please see the section "Generating code/project" for a complete overview of the files generated for a project using the TouchGFX Generator.'),Object(o.b)("p",null,"User code In CubeMX is protected through the use of ",Object(o.b)("strong",{parentName:"p"},"User Code")," sections placed strategically throughout the code generated by CubeMX (C).\xa0In the TouchGFX HAL (C++) generated by TouchGFX Generator this flexibility is accomplished through inheritance."),Object(o.b)("p",null,"Two classes are generated to form the TouchGFX HAL in a CubeMX project using the TouchGFX Generator:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},Object(o.b)("inlineCode",{parentName:"li"},"TouchGFXGeneratedHAL")," - This class contains code based on the configurations of CubeMX and TouchGFX Generator in combination."),Object(o.b)("li",{parentName:"ol"},Object(o.b)("inlineCode",{parentName:"li"},"TouchGFXHAL")," - This class inherits from TouchGFXGeneratedHAL. It is generated once and can then be used by the user to write custom code, e.g. a driver for transferring pixels from a framebuffer over SPI. It can even be used to overwrite/ignore the code generated in TouchGFXGeneratedHAL.")),Object(o.b)("p",null,"The following figure shows the class hierarchy of the generated code."),Object(o.b)(i.a,{imageSource:"/img/Development/TouchGFXHALDevelopment/architecture/dependencies.png",caption:"Project activity",noShadow:!0,mdxType:"Figure"}),Object(o.b)("h2",{id:"generated-project"},"Generated project"),Object(o.b)("p",null,"When generating a project through CubeMX any of the available toolchain / IDE options are supported. For a better project structure select the following options for project generation:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Application structure: Advanced"),Object(o.b)("li",{parentName:"ul"},'Disable "Generate under root"')),Object(o.b)("p",null,"When generating code for a CubeMX project the presence of TouchGFX Generator will create a folder TouchGFX which has the following three entries:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"The ",Object(o.b)("em",{parentName:"li"},"App")," folder which contains code for Init() and Process() functions"),Object(o.b)("li",{parentName:"ul"},"The ",Object(o.b)("em",{parentName:"li"},"target")," folder which contains generated (inside generated/, non-modifiable) and modifiable user classes: Empty implementation of TouchController class, empty implementation of GPIO class which can be used for performance measurements, TouchGFXHAL class which\xa0is the class used by developers to write user code, e.g. how to transfer pixels over a custom display interface, or if a developer wants to extend a method from TouchGFXGeneratedHAL."),Object(o.b)("li",{parentName:"ul"},"The ",Object(o.b)("em",{parentName:"li"},".part")," file which can be opened and understood by TouchGFX Designer in order to create a full TouchGFX project. The part file contains relevant application information such as pixel format, and canvas dimensions.")),Object(o.b)("p",null,"The following code is an example of the contents of a .part file. The post-generate command will update the project selected in CubeMX (e.g. EWARM) when new files are created by the TouchGFX designer (e.g. new screens and assets)."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-json"}),'{\n "Application": {\n "Name": "my_project",\n "TouchGfxPath": "../Middlewares/ST/touchgfx",\n "AvailableColorDepths": [ 16 ],\n "AvailableLCDs":\n  {\n    "16": "LCD16bpp"\n },\n "AvailableResolutions" :\n [\n  {\n    "Width": 320,\n    "Height": 240\n  }\n ],\n "PostGenerateTargetCommand" : "touchgfx update_project --project-file=../my_project.ioc --platform=m7"\n },\n "Version": "4.13.0"\n}\n')),Object(o.b)("p",null,"At this point, developers can work interchangeably in CubeMX, TouchGFX Designer and toolchain/IDE."))}d.isMDXComponent=!0},272:function(e,t,n){"use strict";var r=n(5),a=n(0),o=n.n(a),i=n(269),c=o.a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},o.a.createElement("path",{"fill-rule":"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})),l=function(e){function t(){return e.apply(this,arguments)||this}return Object(r.a)(t,e),t.prototype.render=function(){return o.a.createElement(i.a,{color:"var(--highlight-color-note)",header:"Note",type:"note",icon:c},this.props.children)},t}(a.Component);t.a=l}}]);