(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{176:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return s})),a.d(t,"metadata",(function(){return b})),a.d(t,"rightToc",(function(){return d})),a.d(t,"default",(function(){return h}));var n=a(1),r=a(9),o=(a(0),a(236)),i=a(239),c=a(247),l=a(241),s={id:"hardware-selection-mcu",title:"MCU"},b={id:"Development/HardwareSelection/HardwareComponents/hardware-selection-mcu",title:"MCU",description:"import Figure from '@site/components/Figure';\r",source:"@site/docs\\Development\\HardwareSelection\\HardwareComponents\\mcu.mdx",permalink:"/docs/Development/HardwareSelection/HardwareComponents/hardware-selection-mcu",sidebar:"docs",previous:{title:"Before Selection of Hardware",permalink:"/docs/Development/HardwareSelection/before-selection-of-hardware"},next:{title:"Display",permalink:"/docs/Development/HardwareSelection/HardwareComponents/hardware-selection-display"}},d=[{value:"Cortex\xae-M Cores",id:"cortex-m-cores",children:[]},{value:"Frequency",id:"frequency",children:[]},{value:"Embedded Hardware Acceleration Features",id:"embedded-hardware-acceleration-features",children:[{value:"Chrom-ART (DMA2D: Direct memory access 2D)",id:"chrom-art-dma2d-direct-memory-access-2d",children:[]},{value:"JPEG Hardware codec",id:"jpeg-hardware-codec",children:[]},{value:"Chrom-GRC (GFXMMU)",id:"chrom-grc-gfxmmu",children:[]}]},{value:"Internal Flash",id:"internal-flash",children:[]},{value:"Internal RAM",id:"internal-ram",children:[]},{value:"LCD Controller",id:"lcd-controller",children:[]},{value:"Packages &amp; I/O",id:"packages--io",children:[]},{value:"Memory Interfacing",id:"memory-interfacing",children:[]},{value:"Price",id:"price",children:[]},{value:"Bus Architecture",id:"bus-architecture",children:[]}],p={rightToc:d},m="wrapper";function h(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(o.b)(m,Object(n.a)({},p,a,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"The Microcontroller Unit (MCU) is at the core of any embedded solution and there are a wide variety of options in both costs and features. This page will go through the different variance points of the MCU and what parameters should be considered when deciding on which STM32 MCU you should select for your individual GUI driven application."),Object(o.b)("p",null,"The performance of a graphic applications depends on several points:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Type of core."),Object(o.b)("li",{parentName:"ul"},"The clock frequency."),Object(o.b)("li",{parentName:"ul"},"The availability of graphics accelerators integrated in the MCU."),Object(o.b)("li",{parentName:"ul"},"The size of the RAM allocated to the application (Placement of RAM in external or internal)"),Object(o.b)("li",{parentName:"ul"},"The size of the internal flash and RAM memories."),Object(o.b)("li",{parentName:"ul"},"Number of framebuffers"),Object(o.b)("li",{parentName:"ul"},"The used display interface."),Object(o.b)("li",{parentName:"ul"},"The availability of a Cache memory in the system.")),Object(o.b)(i.a,{imageSource:"/img/Development/HardwareSelection/mcu/MCUportfolio_graphics.png",caption:"STM32 MCU",noShadow:!0,width:"600",mdxType:"Figure"}),Object(o.b)(c.a,{mdxType:"FurtherReading"},Object(o.b)("li",null,"For a more complete overview of all product lines, peripherals, prices etc., ",Object(o.b)(l.a,{to:"https://www.st.com/en/development-tools/st-mcu-finder.html",mdxType:"Link"},"the ST MCU Finder is available here"),".")),Object(o.b)("h2",{id:"cortex-m-cores"},"Cortex\xae-M Cores"),Object(o.b)("p",null,"The ",Object(o.b)("strong",{parentName:"p"}," Cortex\xae-M0+ ")," is characterized by the simple architecture and low price of STM32 products using ",Object(o.b)("strong",{parentName:"p"}," Cortex\xae-M0+ "),".\nThe Cortex-M0+ highly recommended for the low power applications, static graphic applications and using fewer resources and an acceptable resolution quality (QVGA)"),Object(o.b)("p",null,"The ",Object(o.b)("strong",{parentName:"p"}," Cortex\xae-M4 ")," contains more functionalities than that of the ",Object(o.b)("strong",{parentName:"p"}," M0+ ")," and mainly acceleration of calculation.\n",Object(o.b)("strong",{parentName:"p"}," Cortex\xae-M4 ")," has a DSP instructions set and has a single precision FPU unit\nThese instruction sets rid the CPU of enormous software computation and increase the speed of calculates thus the possibility of targetting a screen with a higher resolution and a sharper image quality."),Object(o.b)("p",null,"The ",Object(o.b)("strong",{parentName:"p"}," Cortex\xae-M7 "),", certainly with a more complex architecture but in addition to a DSP instruction set, comes with a more efficient FPU unit with double precision and a level1 cache memory up to ",Object(o.b)("strong",{parentName:"p"}," 16KB ")," for data and instruction.\nThe cache memory gives the possibility of having data and instructions close to the calculation unit in order to optimize the fetch time."),Object(o.b)("table",null,Object(o.b)("thead",{parentName:"table"},Object(o.b)("tr",{parentName:"thead"},Object(o.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Feature"),Object(o.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Cortex-M0+"),Object(o.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Cortex-M4"),Object(o.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Cortex-M7"))),Object(o.b)("tbody",{parentName:"table"},Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"DMIPS/MHz range"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0.95-1.36"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"1.25-1.95"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"2.14-3.23")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Core Mark\xae/MHz"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"2.46"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"3.42"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"5.01")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Digital Signal Processing (DSP) extention"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"No"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Yes"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Yes")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Floating Point Hardware"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"No"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Yes (SP)"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Yes (SP + DP)")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Built-in-caches"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"No"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"No"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Yes (option 4-64KB), I-Cachen D-Cache")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Bus Protocol"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"AHB Lite,Fast I/O"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"AHB Lite, APB"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"AXI4, AHB Lite, APB, TCM")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Dual Core Lock-Step Support"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"No"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"No"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Yes")))),Object(o.b)("h4",{id:"level-1-cache"},"Level 1 Cache:"),Object(o.b)("p",null,"The STM32H7 and STM32F7 families include up to ",Object(o.b)("strong",{parentName:"p"}," 16 Kbytes ")," of L1-Cache both for instructions and data.\nAn L1-Cache stores a set of data or instruction near to the CPU, so the CPU does not have to keep feetching the same data that is repeatedly used."),Object(o.b)(c.a,{mdxType:"FurtherReading"},Object(o.b)("li",null,"Refer to AN4839 application note for more information:, ",Object(o.b)(l.a,{to:"https://www.st.com/content/ccc/resource/technical/document/application_note/group0/08/dd/25/9c/4d/83/43/12/DM00272913/files/DM00272913.pdf/jcr:content/translations/en.DM00272913.pdf",mdxType:"Link"},"Level 1 Cache"),".")),Object(o.b)("h4",{id:"dual-core"},"dual core"),Object(o.b)("p",null,"The STM32H7 series includes dual-core line:\nArm\xae Cortex\xae-M7 and Cortex\xae-M4 cores can respectively run up to 480 MHz and 240 MHz enabling more processing and application partitioning. Dual-core STM32H7 product lines are available with an embedded SMPS for improved dynamic power efficiency"),Object(o.b)("p",null,"The second Cortex\xae-M4 can offload a heavy calculation to allow the M7 core for the drawing/graphic operations."),Object(o.b)("p",null,"Note. TouchGFX Generator is not available as additional software for STM32H7 dual-cores."),Object(o.b)("h2",{id:"frequency"},"Frequency"),Object(o.b)("p",null,"The system frequency has a major impact on performance of a graphical application in terms of screen refresh, fluidity of screens and animations.\nIn fact, the system frequency impacts the number of data that will be transferred from an internal or external memory to the display framebuffer.\nThe higher the system frequency, the greater the number of data is possible to transferred. Also, having a higher CPU core frequency enables more complex algorithms and calculations."),Object(o.b)("p",null,"Running a graphical application with a smooth transition between frames, sliding and a smooth animation requires an MCU with a higher system frequency"),Object(o.b)("p",null,"The system frequency of the STM32 product is up to ",Object(o.b)("strong",{parentName:"p"}," 480MHz "),"  "),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"}," Example of theoretical internal RAM bandwidth with STM32H7 products ")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"CPU Core frequency = ",Object(o.b)("strong",{parentName:"li"}," 480MHz ")),Object(o.b)("li",{parentName:"ul"},"embed 64-bit AXI interconnected running on ",Object(o.b)("strong",{parentName:"li"}," 240MHz "),"."),Object(o.b)("li",{parentName:"ul"},"The LCD-TFT display controller, LTDC, uses a ",Object(o.b)("strong",{parentName:"li"}," 64-bit ")," bus, connected to the AXI bus matrix (8 datas in 10 cycles)."),Object(o.b)("li",{parentName:"ul"},"The internal RAM with no significant latency (0 wait state).")),Object(o.b)("p",null,"The bandwidth of the internal RAM and accessed by the LTDC peripheral is:"),Object(o.b)("p",null,"Number of transfer = 240 x (8/10) = ",Object(o.b)("strong",{parentName:"p"}," 192 Mega transfer /s ")),Object(o.b)("p",null,"Bandwidth          = 192 x 8      = ",Object(o.b)("strong",{parentName:"p"}," 1.536Mbytes/s "),"."),Object(o.b)("p",null,"Note that the higher the system frequency, the greater the power consumption"),Object(o.b)("h2",{id:"embedded-hardware-acceleration-features"},"Embedded Hardware Acceleration Features"),Object(o.b)("h3",{id:"chrom-art-dma2d-direct-memory-access-2d"},"Chrom-ART (DMA2D: Direct memory access 2D)"),Object(o.b)("p",null,"The chrom-ART accelerator integrated in many STM32 platforms is able to manipulate and transfer images without CPU load.\nColor filling or images copying operations, blending and/or pixel format convertion, the chrom-ART have the capability to accelerate the majority of the graphic operations."),Object(o.b)("p",null,"Example of application ranning on ",Object(o.b)("strong",{parentName:"p"}," STM32F496-EVAL ")," board where the CPU load is decreased from ",Object(o.b)("strong",{parentName:"p"}," 82% ")," to ",Object(o.b)("strong",{parentName:"p"}," 4% ")," when the chrom-ART is enabled."),Object(o.b)(i.a,{imageSource:"/img/Development/HardwareSelection/mcu/birdeatcoin.gif",caption:"BirdEatCoin chrom-ART example",mdxType:"Figure"}),Object(o.b)("p",null,"In addition, the capability to convert from ",Object(o.b)("strong",{parentName:"p"}," YCbCr ")," format to ",Object(o.b)("strong",{parentName:"p"}," RGB ")," format is added with STM32H7 products to the chrom-ART peripheral.\nThis feature, combined with the jpeg hardware codec can 100% offload the CPU for the encode and decode jpeg images.   "),Object(o.b)(i.a,{imageSource:"/img/Development/HardwareSelection/mcu/Chrom-ART_acceleration.png",caption:"YCbCr to RGB Hardware performance",noShadow:!0,width:"500",mdxType:"Figure"}),Object(o.b)("p",null,"The Chrom-ART peripheral is available with high perfomance STM32 families. "),Object(o.b)(c.a,{mdxType:"FurtherReading"},Object(o.b)("li",null,"Refer to AN4943 application note for more information:, ",Object(o.b)(l.a,{to:"https://www.st.com/content/ccc/resource/technical/document/application_note/group0/17/82/73/f8/b8/8a/47/c7/DM00338361/files/DM00338361.pdf/jcr:content/translations/en.DM00338361.pdf",mdxType:"Link"},"Chrom-ART Hardware acceleration"),".")),Object(o.b)("h3",{id:"jpeg-hardware-codec"},"JPEG Hardware codec"),Object(o.b)("p",null,"The ",Object(o.b)("strong",{parentName:"p"}," STM32H7 ")," and ",Object(o.b)("strong",{parentName:"p"}," STM32F7 ")," families provide a hardware jpeg codec to encode and decode images and videos operations.\nThis feature is important if the UI application needs to parse a video files (e.g. .AVI container) to redirect the image decoding to tha hardware codec.\nThe images can be stored in Jpeg format and decoded in runtime to save flash memory.\nSome TouchGFX demos are utilizing the JPEG Hardware codec, offloading the CPU while playing a MJPEG video."),Object(o.b)(i.a,{imageSource:"/img/Development/HardwareSelection/mcu/JPEG_Codec_acceleration.png",caption:"Hardware JPEG codec performance",noShadow:!0,width:"500",mdxType:"Figure"}),Object(o.b)("p",null,"Thanks to the new functionality added in the chrom-ART peripheral embedded in STM32H7 products, the conversion of the YCbCr to RGB pixel format is done by hardware and allow to reduce significantly the CPU load."),Object(o.b)(c.a,{mdxType:"FurtherReading"},Object(o.b)("li",null,"Refer to AN4996 application note for more information:, ",Object(o.b)(l.a,{to:"https://www.st.com/content/ccc/resource/technical/document/application_note/group0/a5/9d/22/46/61/6d/4a/ab/DM00356635/files/DM00356635.pdf/jcr:content/translations/en.DM00356635.pdf",mdxType:"Link"},"Hardware JPEG codec"),".")),Object(o.b)("h3",{id:"chrom-grc-gfxmmu"},"Chrom-GRC (GFXMMU)"),Object(o.b)("p",null,"If the chosen display will be a rounded one, it's recommended to choose an STM32 product providing Chrom-GRC peripheral to optimze the memory allocated to the framebuffers.\nThe Chrom-GRC reduce the memory requirement for the framebuffers by ",Object(o.b)("strong",{parentName:"p"}," 20% "),"."),Object(o.b)(i.a,{imageSource:"/img/Development/HardwareSelection/mcu/Chrom_GRC.png",caption:"Memory optimisation with Chrom-GRC peripheral",noShadow:!0,width:"600",mdxType:"Figure"}),Object(o.b)(c.a,{mdxType:"FurtherReading"},Object(o.b)("li",null,"Refer to AN5051 application note for more information:, ",Object(o.b)(l.a,{to:"https://www.st.com/content/ccc/resource/technical/document/application_note/group0/74/21/86/42/af/d5/4f/58/DM00407777/files/DM00407777.pdf/jcr:content/translations/en.DM00407777.pdf",mdxType:"Link"},"Graphic memory optimization"),".")),Object(o.b)("h2",{id:"internal-flash"},"Internal Flash"),Object(o.b)("p",null,"A graphical user interface application using bitmaps resources, needs non-volatile memory to store the data.\nThe size of the internal flash can be very important for the application as execution and access from internal flash is in some cases up to two times faster, but in many cases the internal flash is only used for storing the TouchGFX framework, stack, screen definition and GUI logic while storing all bitmap data in an external flash."),Object(o.b)("p",null,"The portfolio of STM32 products used for graphic aplications is between ",Object(o.b)("strong",{parentName:"p"}," 32Kbytes ")," and ",Object(o.b)("strong",{parentName:"p"}," 2Mbytes ")," of internal flash memory "),Object(o.b)("p",null,"TouchGFX flash memory requirement:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Framework and stack:             60kbytes to 100kbytes."),Object(o.b)("li",{parentName:"ul"},"Screen definition and GUI logic: 1 to 100Kbytes."),Object(o.b)("li",{parentName:"ul"},"Image and font data:             1 to 40Mbytes (depending on application size).")),Object(o.b)("h2",{id:"internal-ram"},"Internal RAM"),Object(o.b)("p",null,"Depending on the chosen display interface, the framebuffers can be placed in different places where RAM is accesible.\nWith DPI or DSI interfaces, we can calculate the RAM memory needed for the framebuffer."),Object(o.b)("p",null,"For example, a display with 480x272 of resolution and 16bits (2bytes) as a color depth, the memory needed for only one framebuffer is calculated as followed:"),Object(o.b)("p",null,"Size of 1 framebuffer = ",Object(o.b)("strong",{parentName:"p"}," 480 x 272 x 2 ")," =  ",Object(o.b)("strong",{parentName:"p"}," 261.120 bytes ")," "),Object(o.b)("p",null,"The portfolio of STM32 products used for graphic aplications is between ",Object(o.b)("strong",{parentName:"p"}," 36Kbytes ")," and ",Object(o.b)("strong",{parentName:"p"}," 640Kbytes ")," of internal RAM memory "),Object(o.b)("p",null,"Below, TouchGFX RAM memory requirement:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Framework and stak: ",Object(o.b)("strong",{parentName:"li"}," 10Kbytes ")," to ",Object(o.b)("strong",{parentName:"li"}," 30Kbytes ")),Object(o.b)("li",{parentName:"ul"},"Widgets:            ",Object(o.b)("strong",{parentName:"li"}," 1Kbytes ")," to ",Object(o.b)("strong",{parentName:"li"}," 15Kbytes ")),Object(o.b)("li",{parentName:"ul"},"Framebuffers:       ",Object(o.b)("strong",{parentName:"li"}," 10Kbytes ")," to ",Object(o.b)("strong",{parentName:"li"}," 3Mbytes ")," (depending on display resolution, color depth and number of framebuffers)")),Object(o.b)("h2",{id:"lcd-controller"},"LCD Controller"),Object(o.b)("p",null,"The choice of the MCU also depends on the choice of the display interface that will be used and the resolution.\nThe 800x480 Resolution for example can only be achieved with an efficient interface in terms of data transfer speed.\nRGB-TFT and MPI-DSI interfaces are often used for higher resolutions, as the bandwidth is in many cases higher than SPI or Parallel 8080/6800.\nIn displays embedding RAM for a framebuffer, it often includes a GRAM (display controller). For MIPI-DSI and RGB-TFT displays, the LTDC is used for display controlling."),Object(o.b)(i.a,{imageSource:"/img/Development/HardwareSelection/mcu/Interfaces.png",caption:"The picture shows 4 examples of different display interfaces with/without GRAM and display controller.",noShadow:!0,width:"600",mdxType:"Figure"}),Object(o.b)("h2",{id:"packages--io"},"Packages & I/O"),Object(o.b)("p",null,"The number of I/O needed is depending on the choosen display, and external memories.\nRunning a parallel display with parallel RAM/flash can required a high number of I/Os resulting in a larger package.       "),Object(o.b)("p",null,"Refer to ",Object(o.b)("strong",{parentName:"p"}," Display ")," section for more information about the number of needed pins for each display interface."),Object(o.b)("h2",{id:"memory-interfacing"},"Memory Interfacing"),Object(o.b)("p",null,"When internal flash and RAM in the microcontroller is not sufficient, choosing the right MCU with the most suitable external memory interface becomes important.\nThe STM32 products provides different memory controller peripherals to interface with the SRAM, SDRAM, NOR, NAND and PSRAM memories. "),Object(o.b)("h4",{id:"flexible-memory-controller-fmc"},"Flexible Memory Controller (FMC)"),Object(o.b)("p",null,"The flexible memory controller (FMC) has an external access speed up to ",Object(o.b)("strong",{parentName:"p"}," 100MHz "),"\nWith independent chip select for each memory bank, the FMC can control an external flash memory for the data and external RAM memory for the framebuffer or heap extention for the graphical stack."),Object(o.b)("h4",{id:"serial-memory-interface"},"Serial memory interface"),Object(o.b)("p",null,"Depending on the STM32 product, Serial memory interface is embedded and allowing interfacing with single, double, quad, Octo, hyperBus flash memories.\nThe Serial memory interface running up to ",Object(o.b)("strong",{parentName:"p"}," 133MHz ")," and up to ",Object(o.b)("strong",{parentName:"p"}," 256Mbytes ")," as adressable space for the memory mapped mode and ",Object(o.b)("strong",{parentName:"p"}," 4Gbytes ")," for indirect mode."),Object(o.b)("p",null,"Compared to parallel interfaces, the serial memory interface permits the connection of a lower cost externa flash memory to small packages and reducing the number of used pins since the maximum used pins are only 12."),Object(o.b)(c.a,{mdxType:"FurtherReading"},Object(o.b)("li",null,"Refer to AN4760 application note for more information:, ",Object(o.b)(l.a,{to:"https://www.st.com/content/ccc/resource/technical/document/application_note/group0/b0/7e/46/a8/5e/c1/48/01/DM00227538/files/DM00227538.pdf/jcr:content/translations/en.DM00227538.pdf",mdxType:"Link"},"Quad-SPI interface on STM32 microcontrollers"),".")),Object(o.b)("h4",{id:"stm32-value-lines-products"},"STM32 Value lines products"),Object(o.b)("p",null,"For prices optimization, STM32H7 and STM32F7 platforms provides value line products with limited internal flash size.\nWith these products, the graphic resources will be stored in the external falsh. and a memory extansion need to be taken into account for the graphical applications."),Object(o.b)("h2",{id:"price"},"Price"),Object(o.b)("p",null,"The size of the internal flash, Internal RAM, and number of pins avalaible in the package are concidered in the price of the MCU.\nDepending on the needs in term of interface, resolution, performance, the user can estimate and optimize the needed MCU."),Object(o.b)("h2",{id:"bus-architecture"},"Bus Architecture"),Object(o.b)("p",null,"The majority of STM32 microcontrollers provides a ",Object(o.b)("strong",{parentName:"p"}," 32-bits multi-AHB ")," bus matrix interconnects all the masters (CPU, DMAs, ...) and the slaves (fash memory, RAM, FSMC, AHB and APB peripherals) and ensures a\nseamless and efficient operation even when several high-speed peripherals work simultaneously."),Object(o.b)("p",null,"In addition to multi-AHB intecterconnect, some STM32 products embed ",Object(o.b)("strong",{parentName:"p"}," 64-bit ")," AXI interconnected to expand bandwidth. Giving the best compromise between performance and power consumption "),Object(o.b)(c.a,{mdxType:"FurtherReading"},Object(o.b)("li",null,"See ",Object(o.b)(l.a,{to:"https://www.st.com/en/microcontrollers-microprocessors/stm32-32-bit-arm-cortex-mcus.html",mdxType:"Link"},"STM32 32-bit Arm Cortex MCUs")," for available STM32 microcontrollers.")))}h.isMDXComponent=!0}}]);