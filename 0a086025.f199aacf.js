(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{139:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return s})),a.d(t,"metadata",(function(){return b})),a.d(t,"rightToc",(function(){return p})),a.d(t,"default",(function(){return h}));var n=a(1),r=a(9),o=(a(0),a(261)),i=a(262),c=a(271),l=a(264),s={id:"hardware-selection-mcu",title:"MCU"},b={id:"development/hardware-selection/hardware-components/hardware-selection-mcu",title:"MCU",description:"import Figure from '@site/components/Figure';",source:"@site/docs\\development\\hardware-selection\\hardware-components\\hardware-selection-mcu.mdx",permalink:"/docs/development/hardware-selection/hardware-components/hardware-selection-mcu",sidebar:"docs",previous:{title:"Preliminary Considerations",permalink:"/docs/development/hardware-selection/preliminary-considerations"},next:{title:"Display",permalink:"/docs/development/hardware-selection/hardware-components/hardware-selection-display"}},p=[{value:"Frequency",id:"frequency",children:[]},{value:"Embedded Hardware Acceleration Features",id:"embedded-hardware-acceleration-features",children:[{value:"Chrom-ART (DMA2D: Direct memory access 2D)",id:"chrom-art-dma2d-direct-memory-access-2d",children:[]},{value:"JPEG Hardware codec",id:"jpeg-hardware-codec",children:[]},{value:"Chrom-GRC (GFXMMU)",id:"chrom-grc-gfxmmu",children:[]}]},{value:"Internal Flash",id:"internal-flash",children:[]},{value:"Internal RAM",id:"internal-ram",children:[]},{value:"LCD Controller",id:"lcd-controller",children:[]},{value:"Packages &amp; I/O",id:"packages--io",children:[]},{value:"Memory Interfacing",id:"memory-interfacing",children:[]},{value:"Cortex\xae-M Cores",id:"cortex-m-cores",children:[]},{value:"Bus Architecture",id:"bus-architecture",children:[]},{value:"Price",id:"price",children:[]}],d={rightToc:p},m="wrapper";function h(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(o.b)(m,Object(n.a)({},d,a,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"The Microcontroller Unit (MCU) is at the core of any embedded solution and there are a wide variety of options in both costs and features. "),Object(o.b)("p",null,"To select an MCU, a variance point should be taken into account, such the display interface support,\nthe MCU package and size and the performance of a graphic applications which depends on two main points:"),Object(o.b)("h4",{id:"image-composition"},"Image composition"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"The availability of graphics accelerators integrated in the MCU."),Object(o.b)("li",{parentName:"ul"},"The availability of a Cache memory in the system.")),Object(o.b)("h4",{id:"memory-access-and-bandwidth"},"Memory access and bandwidth"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"The clock frequency and the subsystem frequency."),Object(o.b)("li",{parentName:"ul"},"The access to the internal flash and RAM memories.")),Object(o.b)("p",null,"To manage the other parts of the application in addition of the graphic, the resources available in the MCU, the architecture and the core are also important."),Object(o.b)("p",null,"This page will go through the different variance points of the MCU and what parameters should be considered when deciding on which STM32 MCU you should select for your individual GUI driven application."),Object(o.b)(i.a,{imageSource:"/img/development/hardware-selection/mcu/mcu-portfolio-graphics.png",caption:"STM32 MCU",noShadow:!0,width:"600",mdxType:"Figure"}),Object(o.b)(c.a,{mdxType:"FurtherReading"},Object(o.b)("li",null,"For a more complete overview of all product lines, peripherals, prices etc., ",Object(o.b)(l.a,{to:"https://www.st.com/en/development-tools/st-mcu-finder.html",mdxType:"Link"},"the ST MCU Finder is available here"),".")),Object(o.b)("h2",{id:"frequency"},"Frequency"),Object(o.b)("p",null,"The system frequency has a major impact on performance of a graphical application in terms of screen refresh, fluidity of screens and animations.\nIn fact, the system frequency impacts the number of data that will be transferred from an internal or external memory to the display framebuffer.\nThe higher the system frequency, the greater the number of data is possible to transfer.\nIt is important to differentiate CPU frequency from Graphic subsystem frequency.\nThe graphic subsystem frequency includes the graphic accelerator frequency as well as internal and external memories access frequency that has the major impact on the graphic performance\nHaving a higher CPU core frequency enables more complex algorithms and calculations."),Object(o.b)("p",null,"Running a graphical application with a smooth transition between frames, sliding and a smooth animation requires an MCU with a higher system frequency"),Object(o.b)("p",null,"The system frequency of the STM32 product is up to ",Object(o.b)("strong",{parentName:"p"}," 480MHz "),"  "),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"}," Example of theoretical internal RAM bandwidth with STM32H7 products ")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"CPU Core frequency = ",Object(o.b)("strong",{parentName:"li"}," 480MHz ")),Object(o.b)("li",{parentName:"ul"},"Embed 64-bit AXI interconnected running on ",Object(o.b)("strong",{parentName:"li"}," 240MHz "),"."),Object(o.b)("li",{parentName:"ul"},"The LCD-TFT display controller, LTDC, uses a ",Object(o.b)("strong",{parentName:"li"}," 64-bit ")," bus, connected to the AXI bus matrix (8 data in 10 cycles)."),Object(o.b)("li",{parentName:"ul"},"The internal RAM with no significant latency (0 wait state).")),Object(o.b)("p",null,"The bandwidth of the internal RAM and accessed by the LTDC peripheral is:"),Object(o.b)("p",null,"Number of transfer = 240 x (8/10) = ",Object(o.b)("strong",{parentName:"p"}," 192 Mega transfer /s ")),Object(o.b)("p",null,"Bandwidth          = 192 x 8      = ",Object(o.b)("strong",{parentName:"p"}," 1.536Mbytes/s "),"."),Object(o.b)("p",null,"With such bandwidth, the internal RAM can ensure 1000 frame per second (fps) for 800x480 resolution and 32bpp as color depth and the limit will not be the framebuffer\nbut the pixel clock of the LTDC peripheral or the pixel clock of the chosen screen."),Object(o.b)("p",null,"Note that the higher the system frequency, the greater the power consumption"),Object(o.b)("h2",{id:"embedded-hardware-acceleration-features"},"Embedded Hardware Acceleration Features"),Object(o.b)("h3",{id:"chrom-art-dma2d-direct-memory-access-2d"},"Chrom-ART (DMA2D: Direct memory access 2D)"),Object(o.b)("p",null,"The Chrom-ART accelerator integrated in many STM32 platforms is able to manipulate and transfer images without CPU load.\nColor filling or images copying operations, blending and/or pixel format conversion, the chrom-ART have the capability to accelerate the majority of the graphic operations."),Object(o.b)("p",null,'The DMA2D is able to perform the blending of two plans and convert the initial pixel format to configured output pixel format and transfer the resulted picture to the memory destination in only one operation.\nThe Chrom-ART is able also to embed a color look up table (CLUT) and coding only the color position instead of the full color of each pixel so memory optimization.\nThe Chrom-ART offer the possibility to define "line offset" for the input and output address\nso using this feature it\'s possible to manage address jumps (This, allows for example to accelerate a copy of an icon from flash memory to the display framebuffer).'),Object(o.b)("p",null,"Example of application running on ",Object(o.b)("strong",{parentName:"p"}," STM32F496-EVAL ")," board where the CPU load is decreased from ",Object(o.b)("strong",{parentName:"p"}," 82% ")," to ",Object(o.b)("strong",{parentName:"p"}," 4% ")," when the chrom-ART is enabled."),Object(o.b)(i.a,{imageSource:"/img/development/hardware-selection/mcu/birdeatcoin.gif",caption:"Bird-Eat-Coin chrom-ART example",mdxType:"Figure"}),Object(o.b)("p",null,"In addition, the capability to convert from ",Object(o.b)("strong",{parentName:"p"}," YCbCr ")," format to ",Object(o.b)("strong",{parentName:"p"}," RGB ")," format is added with STM32H7 products to the chrom-ART peripheral.\nThis feature, combined with the jpeg hardware codec can 100% offload the CPU for encode and decode jpeg images.   "),Object(o.b)(i.a,{imageSource:"/img/development/hardware-selection/mcu/chrom-art-acceleration.png",caption:"YCbCr to RGB Hardware performance",noShadow:!0,width:"500",mdxType:"Figure"}),Object(o.b)("p",null,"Knowing the features listed above, the Chrom-ART peripheral represents a huge advantage for the graphical applications.\nIf available in the chosen MCU, TouchGFX, handle all chrom-ART features and redirects all possible drawing operations to the chrom-ART peripheral instead of the CPU."),Object(o.b)("p",null,"The Chrom-ART peripheral is available with high performance STM32 families. "),Object(o.b)(c.a,{mdxType:"FurtherReading"},Object(o.b)("li",null,"Refer to AN4943 application note for more information:, ",Object(o.b)(l.a,{to:"https://www.st.com/content/ccc/resource/technical/document/application_note/group0/17/82/73/f8/b8/8a/47/c7/DM00338361/files/DM00338361.pdf/jcr:content/translations/en.DM00338361.pdf",mdxType:"Link"},"Chrom-ART Hardware acceleration"),".")),Object(o.b)("h3",{id:"jpeg-hardware-codec"},"JPEG Hardware codec"),Object(o.b)("p",null,"The ",Object(o.b)("strong",{parentName:"p"}," STM32H7 ")," and ",Object(o.b)("strong",{parentName:"p"}," STM32F7 ")," families provide a hardware jpeg codec to encode and decode images and videos operations.\nThis feature is important if the UI application needs to parse a video files (e.g. .AVI container) to redirect the image decoding to the hardware codec.\nThe images can be stored in Jpeg format and decoded in runtime to save flash memory.\nSome TouchGFX demos are utilizing the JPEG Hardware codec, offloading the CPU while playing a MJPEG video."),Object(o.b)(i.a,{imageSource:"/img/development/hardware-selection/mcu/jpeg-codec-acceleration.png",caption:"Hardware JPEG codec performance",noShadow:!0,width:"500",mdxType:"Figure"}),Object(o.b)(c.a,{mdxType:"FurtherReading"},Object(o.b)("li",null,"Refer to AN4996 application note for more information:, ",Object(o.b)(l.a,{to:"https://www.st.com/content/ccc/resource/technical/document/application_note/group0/a5/9d/22/46/61/6d/4a/ab/DM00356635/files/DM00356635.pdf/jcr:content/translations/en.DM00356635.pdf",mdxType:"Link"},"Hardware JPEG codec"),".")),Object(o.b)("h3",{id:"chrom-grc-gfxmmu"},"Chrom-GRC (GFXMMU)"),Object(o.b)("p",null,"The STM32 Chrom-GRC\u2122 (GFXMMU) peripheral is a new addition to STM32 microcontrollers aiming to efficiently support this\nemerging trend towards non-rectangular displays.\nGFXMMU enables to store only the visible parts of the non-square displays and in the\ncase of round displays, this peripheral reduces by ",Object(o.b)("strong",{parentName:"p"}," 20% ")," the memory requirements to store\nthe graphic framebuffer. "),Object(o.b)("p",null,"The GFXMMU peripheral is not necessary to control non-square screen but it is recommended in such cases."),Object(o.b)(i.a,{imageSource:"/img/development/hardware-selection/mcu/stm-32-chrom-grc.png",caption:"Memory optimization with Chrom-GRC peripheral",noShadow:!0,width:"600",mdxType:"Figure"}),Object(o.b)(c.a,{mdxType:"FurtherReading"},Object(o.b)("li",null,"Refer to AN5051 application note for more information:, ",Object(o.b)(l.a,{to:"https://www.st.com/content/ccc/resource/technical/document/application_note/group0/74/21/86/42/af/d5/4f/58/DM00407777/files/DM00407777.pdf/jcr:content/translations/en.DM00407777.pdf",mdxType:"Link"},"Graphic memory optimization"),".")),Object(o.b)("h2",{id:"internal-flash"},"Internal Flash"),Object(o.b)("p",null,"A graphical user interface application using bitmaps resources, needs non-volatile memory to store the data.\nThe size of the internal flash can be very important for the application as execution and access from internal flash is in some cases up to two times faster, but in many cases the internal flash is only used for storing the TouchGFX framework, screen definition and GUI logic while storing all bitmap data in an external flash."),Object(o.b)("p",null,"The portfolio of STM32 products used for graphic applications is between ",Object(o.b)("strong",{parentName:"p"}," few Kbytes ")," and ",Object(o.b)("strong",{parentName:"p"}," few Mega bytes ")," of internal flash memory "),Object(o.b)("p",null,"Note: External memories maybe required to allow rich user interface (UI) with important color depths when internal flash is not enough."),Object(o.b)("p",null,"Refer to  ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/docs/development/hardware-selection/hardware-components/hardware-selection-external-memories"}),Object(o.b)("strong",{parentName:"a"}," External memory "))," article for more details."),Object(o.b)("p",null,"TouchGFX flash memory requirement:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Framework:                       ",Object(o.b)("strong",{parentName:"li"}," 60kbytes ")," to ",Object(o.b)("strong",{parentName:"li"}," 100kbytes "),"."),Object(o.b)("li",{parentName:"ul"},"Screen definition and GUI logic: ",Object(o.b)("strong",{parentName:"li"}," 1 ")," to ",Object(o.b)("strong",{parentName:"li"}," 100Kbytes "),".")),Object(o.b)("h2",{id:"internal-ram"},"Internal RAM"),Object(o.b)("p",null,"Depending on the chosen display interface, the framebuffers can be placed in different places where RAM is accessible.\nWith DPI or DSI interfaces, we can calculate the RAM memory needed for the framebuffer."),Object(o.b)("p",null,"For example, a display with HVGA resolution (480x320) and 16bits (2bytes) as a color depth, the memory needed for only one framebuffer is calculated as followed:"),Object(o.b)("p",null,"Size of 1 framebuffer = ",Object(o.b)("strong",{parentName:"p"}," 480 x 320 x 2 ")," =  ",Object(o.b)("strong",{parentName:"p"}," 307.200 bytes ")," "),Object(o.b)("p",null,"The portfolio of STM32 products used for graphic applications is between ",Object(o.b)("strong",{parentName:"p"}," few Kbytes ")," and ",Object(o.b)("strong",{parentName:"p"}," few Mega Bytes ")," of internal RAM memory "),Object(o.b)("p",null,"Note: External memories maybe required to support high resolutions when internal RAM is not enough."),Object(o.b)("p",null,"Refer to  ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/docs/development/hardware-selection/hardware-components/hardware-selection-external-memories"}),Object(o.b)("strong",{parentName:"a"}," External memory "))," article for more details."),Object(o.b)("p",null,"Below, the typical TouchGFX RAM memory requirement:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Framework:          ",Object(o.b)("strong",{parentName:"li"}," 10Kbytes ")," to ",Object(o.b)("strong",{parentName:"li"}," 30Kbytes ")),Object(o.b)("li",{parentName:"ul"},"Widgets:            ",Object(o.b)("strong",{parentName:"li"}," 1Kbytes ")," to ",Object(o.b)("strong",{parentName:"li"}," 15Kbytes "))),Object(o.b)("p",null,"Note: Please note that memory requirement may vary from application to application."),Object(o.b)("h2",{id:"lcd-controller"},"LCD Controller"),Object(o.b)("p",null,"The choice of the MCU also depends on the choice of the display interface that will be used and the resolution.\nThe 800x480 Resolution for example can only be achieved with an efficient interface in terms of data transfer speed.\nRGB-TFT and MPI-DSI interfaces are often used for higher resolutions, as the bandwidth is in many cases higher than SPI or Parallel 8080/6800.\nSmall resolution displays often embed controller and GRAM and so can be connected through simple SPI or 8080/6800 interfaces.\nHigh resolutions display (WQVGA and above) oven don\u2019t embed controller and GRAM, controller needs then to be at the microcontroller side. On STM32 RGB-TFT and MIPI DSI controllers are embedded in graphic part numbers to allow control of such displays."),Object(o.b)("p",null,"Refer to ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/docs/development/hardware-selection/hardware-components/hardware-selection-display"}),Object(o.b)("strong",{parentName:"a"}," Display "))," article for more information."),Object(o.b)(i.a,{imageSource:"/img/development/hardware-selection/mcu/display-interfaces.png",caption:"The picture shows 4 examples of different display interfaces with/without GRAM and display controller.",noShadow:!0,width:"600",mdxType:"Figure"}),Object(o.b)("h2",{id:"packages--io"},"Packages & I/O"),Object(o.b)("p",null,"The number of I/O needed is depending on the chosen display, and external memories.\nRunning a parallel display with parallel RAM/flash can required a high number of I/Os resulting in a larger package.       "),Object(o.b)("h2",{id:"memory-interfacing"},"Memory Interfacing"),Object(o.b)("p",null,"When internal flash and RAM in the microcontroller is not sufficient, choosing the right MCU with the most suitable external memory interface becomes important.\nThe STM32 products provides different memory controller peripherals to interface with the NOR, NAND, SRAM, SDRAM, LPSDR SDRAM, and PSRAM memories. "),Object(o.b)("h4",{id:"flexible-memory-controller---flexible-static-memory-controller-fmcfsmc"},"Flexible Memory Controller &  Flexible static Memory Controller (FMC/FSMC)"),Object(o.b)("p",null,"In addition to the support of the static RAM, the FMC adds to FSMC the dynamic RAM support (SDRAM).\nThe flexible memory controller (FMC) with a high external access speed and with 8, 16 and especially 32 bit data bus, the FMC allows higher throughout of the RAM extension and then better support of high resolution.\nThe FMC have an independent chip select for each memory bank, the FMC can control an external flash memory for the data and external RAM memory for the framebuffer or heap extension for the graphical stack."),Object(o.b)("h4",{id:"serial-memory-interface"},"Serial memory interface"),Object(o.b)("p",null,"Depending on the STM32 product, Serial memory interface is embedded and allowing interfacing with single, double, quad, Octo, hyperBus flash memories and QSPI, PSRAM, OPI PSRAM, and Hyper RAM memories.\nThe Serial high speed memory interface with up to ",Object(o.b)("strong",{parentName:"p"}," 256 Mbytes ")," as addressable space for the memory mapped mode and ",Object(o.b)("strong",{parentName:"p"}," 4Gbytes ")," for indirect mode."),Object(o.b)("p",null,"Compared to parallel interfaces, the serial memory interface permits the connection of a lower cost extern flash memory to small packages and reducing the number of used pins since the maximum used pins are only 12."),Object(o.b)(c.a,{mdxType:"FurtherReading"},Object(o.b)("li",null,"Refer to AN4760 application note for more information:, ",Object(o.b)(l.a,{to:"https://www.st.com/content/ccc/resource/technical/document/application_note/group0/b0/7e/46/a8/5e/c1/48/01/DM00227538/files/DM00227538.pdf/jcr:content/translations/en.DM00227538.pdf",mdxType:"Link"},"Quad-SPI interface on STM32 microcontrollers"),".")),Object(o.b)("h4",{id:"stm32-value-line-products"},"STM32 Value line products"),Object(o.b)("p",null,"For prices optimization, STM32H7 and STM32F7 platforms provides value line products with limited internal flash size.\nWith these products, the graphic resources will be stored in the external flash.\nMemory extension need to be taken into account for the graphical applications."),Object(o.b)("h2",{id:"cortex-m-cores"},"Cortex\xae-M Cores"),Object(o.b)("p",null,"The ",Object(o.b)("strong",{parentName:"p"}," Cortex\xae-M0+ ")," is characterized by the simple architecture and low price of STM32 products using ",Object(o.b)("strong",{parentName:"p"}," Cortex\xae-M0+ "),".\nThe Cortex-M0+ highly recommended for the static graphic applications and using fewer resources and an acceptable resolution quality (QVGA)"),Object(o.b)("p",null,"The ",Object(o.b)("strong",{parentName:"p"}," Cortex\xae-M4 ")," contains more functionalities than that of the ",Object(o.b)("strong",{parentName:"p"}," M0+ ")," and mainly acceleration of calculation.\n",Object(o.b)("strong",{parentName:"p"}," Cortex\xae-M4 ")," has a DSP instructions set and has a single precision FPU unit.\nThese instruction sets rid the CPU of enormous software computation and increase the speed of calculates."),Object(o.b)("p",null,"The ",Object(o.b)("strong",{parentName:"p"}," Cortex\xae-M7 "),", certainly with a more complex architecture but in addition to a DSP instruction set, comes with a more efficient FPU unit with double precision and a level1 cache memory up to ",Object(o.b)("strong",{parentName:"p"}," 16KB ")," for data and instruction.\nThe cache memory gives the possibility of having data and instructions close to the calculation unit in order to optimize the fetch time."),Object(o.b)("table",null,Object(o.b)("thead",{parentName:"table"},Object(o.b)("tr",{parentName:"thead"},Object(o.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Feature"),Object(o.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Cortex-M0+"),Object(o.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Cortex-M4"),Object(o.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Cortex-M7"))),Object(o.b)("tbody",{parentName:"table"},Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"DMIPS/MHz range"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0.95-1.36"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"1.25-1.95"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"2.14-3.23")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Core Mark\xae/MHz"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"2.46"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"3.42"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"5.01")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Digital Signal Processing (DSP) extension"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"No"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Yes"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Yes")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Floating Point Hardware"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"No"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Yes (SP)"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Yes (SP + DP)")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Built-in-caches"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"No"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"No"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Yes (option 4-64KB), I-Cachen D-Cache")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Bus Protocol"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"AHB Lite,Fast I/O"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"AHB Lite, APB"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"AXI4, AHB Lite, APB, TCM")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Dual Core Lock-Step Support"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"No"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"No"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Yes")))),Object(o.b)("h4",{id:"level-1-cache"},"Level 1 Cache:"),Object(o.b)("p",null,"The STM32H7 and STM32F7 families include up to ",Object(o.b)("strong",{parentName:"p"}," 16 Kbytes ")," of L1-Cache both for instructions and data.\nAn L1-Cache stores a set of data or instruction near to the CPU, so the CPU does not have to keep fetching the same data that is repeatedly used."),Object(o.b)(c.a,{mdxType:"FurtherReading"},Object(o.b)("li",null,"Refer to AN4839 application note for more information:, ",Object(o.b)(l.a,{to:"https://www.st.com/content/ccc/resource/technical/document/application_note/group0/08/dd/25/9c/4d/83/43/12/DM00272913/files/DM00272913.pdf/jcr:content/translations/en.DM00272913.pdf",mdxType:"Link"},"Level 1 Cache"),".")),Object(o.b)("h4",{id:"dual-core"},"dual core"),Object(o.b)("p",null,"The STM32H7 series includes dual-core line:\nArm\xae Cortex\xae-M7 and Cortex\xae-M4 cores can respectively run up to 480 MHz and 240 MHz enabling more processing and application partitioning. Dual-core STM32H7 product lines are available with an embedded SMPS for improved dynamic power efficiency"),Object(o.b)("p",null,"The second Cortex\xae-M4 can offload a heavy calculation to allow the M7 core for the drawing/graphic operations."),Object(o.b)("p",null,"Note. TouchGFX Generator is not available as additional software for STM32H7 dual-cores."),Object(o.b)("h2",{id:"bus-architecture"},"Bus Architecture"),Object(o.b)("p",null,"The majority of STM32 microcontrollers provides a ",Object(o.b)("strong",{parentName:"p"}," 32-bits multi-AHB ")," bus matrix interconnects all the masters (CPU, DMAs, ...) and the slaves (flash memory, RAM, FSMC, AHB and APB peripherals) and ensures a\nseamless and efficient operation even when several high-speed peripherals work simultaneously."),Object(o.b)("p",null,"In addition to multi-AHB interconnect, some STM32 (Cortex\xae-M7) products embed ",Object(o.b)("strong",{parentName:"p"}," 64-bit ")," AXI interconnected to expand bandwidth. Giving the best compromise between performance and power consumption "),Object(o.b)("h2",{id:"price"},"Price"),Object(o.b)("p",null,"The size of the internal flash, Internal RAM, and number of pins available in the package are considered in the price of the MCU.\nDepending on the needs in term of interface, resolution, performance, the user can estimate and optimize the needed MCU."),Object(o.b)(c.a,{mdxType:"FurtherReading"},Object(o.b)("li",null,"See ",Object(o.b)(l.a,{to:"https://www.st.com/en/microcontrollers-microprocessors/stm32-32-bit-arm-cortex-mcus.html",mdxType:"Link"},"STM32 32-bit Arm Cortex MCUs")," for available STM32 microcontrollers.")))}h.isMDXComponent=!0}}]);