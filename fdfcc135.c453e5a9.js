(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{221:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return l})),a.d(t,"metadata",(function(){return h})),a.d(t,"rightToc",(function(){return m})),a.d(t,"default",(function(){return d}));var n=a(1),r=a(9),c=(a(0),a(227)),o=a(229),i=(a(246),a(235),a(248),a(231)),p=a(232),s=a(230),l=(a(234),{id:"UsingNonMemoryMappedFlashForStoringImages",title:"Using Non-Memory Mapped Flash for Storing Images"}),h={id:"Development/UIDevelopment/Scenarios/UsingNonMemoryMappedFlashForStoringImages",title:"Using Non-Memory Mapped Flash for Storing Images",description:"import Figure from '@site/components/Figure';",source:"@site/docs\\Development\\UIDevelopment\\Scenarios\\UsingNonMemoryMappedFlashForStoringImages.mdx",permalink:"/docs/Development/UIDevelopment/Scenarios/UsingNonMemoryMappedFlashForStoringImages",sidebar:"docs",previous:{title:"Lowering Memory Usage with Partial Framebuffer",permalink:"/docs/Development/UIDevelopment/Scenarios/LoweringMemoryUsageWithPartialFrameBuffer"},next:{title:"Using the L8 Image Format to Reduce Memory Consumption",permalink:"/docs/Development/UIDevelopment/Scenarios/UsingTheL8ImageFormatToReduceMemoryConsumption"}},m=[{value:"Partial Bitmap caching",id:"partial-bitmap-caching",children:[]},{value:"Cache Operations",id:"cache-operations",children:[]},{value:"Cache Bitmap on a Screen basis",id:"cache-bitmap-on-a-screen-basis",children:[]},{value:"Replace the background Bitmap",id:"replace-the-background-bitmap",children:[]},{value:"Cache Memory Management",id:"cache-memory-management",children:[]}],u={rightToc:m},b="wrapper";function d(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(c.b)(b,Object(n.a)({},u,a,{components:t,mdxType:"MDXLayout"}),Object(c.b)("p",null,"This article describes how the bitmap caching system can be used to create applications where the total size of the bitmaps is greater than the amount of RAM available. The techniques are mostly relevant if your external flash is not memory mapped."),Object(c.b)("p",null,"Recall that bitmaps must be placed in addressable flash or RAM to be useable for TouchGFX.\nThe most basic setup is to have the bitmaps placed in external flash. The bitmaps are copied directly from the external flash to the frame buffer in RAM when shown on the LCD."),Object(c.b)("p",null,"To access bitmaps stored in non adressable memory, ",Object(c.b)(p.a,{text:"bool HAL::blockCopy(void* RESTRICT dest, const void* RESTRICT src, uint32_t numBytes)",mdxType:"InlineCode"})," is required to be implemented, in your boards Hardware Abstraction Layer (HAL)."),Object(c.b)(i.a,{mdxType:"FurtherReading"},Object(c.b)("li",null,Object(c.b)(s.a,{to:"/docs/",mdxType:"Link"},"See the article Non-memory mapped external flash for an introduction to setting up bitmap caching ###TODO_REAL_LINK"))),Object(c.b)("h2",{id:"partial-bitmap-caching"},"Partial Bitmap caching"),Object(c.b)("p",null,"When the amount of RAM that you can allocate for your bitmap cache is less than the total size of the bitmaps you can not cache all the bitmaps during startup.\nYou need to cache only the bitmaps needed for the first screen. When you change between your screens you can remove some or all of the cached bitmaps and cache the bitmaps needed for the next screen."),Object(c.b)("h2",{id:"cache-operations"},"Cache Operations"),Object(c.b)("p",null,"The bitmap caching operations are all placed in the Bitmap class."),Object(c.b)("p",null,"The following method caches a bitmap. The bitmap is only cached if enough unused memory is available in the cache. Returns true if the bitmap was cached."),Object(c.b)("pre",null,Object(c.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp"}),"static bool Bitmap::cache(BitmapId id)\n")),Object(c.b)("p",null,"The following method replaces a bitmap (out) in the cache with another bitmap (in). The method will only succeed if the bitmap to be replaced is cached and if the bitmaps have the same size (in bytes)."),Object(c.b)("pre",null,Object(c.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp"}),"static bool Bitmap::cacheReplaceBitmap(BitmapId out, BitmapId in)\n")),Object(c.b)("p",null,"The following method removes a bitmap from the cache. The memory used by the bitmap can be used for caching of another bitmap afterwards."),Object(c.b)("pre",null,Object(c.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp"}),"static bool Bitmap::cacheRemoveBitmap(BitmapId id)\n")),Object(c.b)("p",null,"The following method removes all the cached bitmaps from the cache."),Object(c.b)("pre",null,Object(c.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp"}),"static void Bitmap::clearCache()\n")),Object(c.b)("p",null,"The following method caches all bitmaps. It can not be used if the amount of RAM allocated for the cache (or available) is less than the total size of the bitmaps."),Object(c.b)("pre",null,Object(c.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp"}),"static void Bitmap::cacheAll()\n")),Object(c.b)("h2",{id:"cache-bitmap-on-a-screen-basis"},"Cache Bitmap on a Screen basis"),Object(c.b)("p",null,"Your application user interface is composed of a set of Views. The Views probably all use some bitmaps.\nA simple strategy for caching is to cache all the bitmaps used by a View in the ",Object(c.b)(p.a,{text:"View::setupScreen",mdxType:"InlineCode"})," method and clear the cache in the ",Object(c.b)(p.a,{text:"View::tearDownScreen",mdxType:"InlineCode"})," method:"),Object(c.b)("pre",null,Object(c.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp"}),"void Screen1View::setupScreen()\n{\n    //ensure background is cached\n    Bitmap::cache(BITMAP_SCREEN2_ID);\n    //cache some icons\n    Bitmap::cache(BITMAP_ICON10_ID);\n    Bitmap::cache(BITMAP_ICON11_ID);\n    Bitmap::cache(BITMAP_ICON12_ID);\n}\n\nvoid Screen1View::tearDownScreen()\n{\n    Bitmap::clearCache();\n}\n")),Object(c.b)("p",null,'The memory requirement for the cache is the size of the bitmaps used by the "largest" screen.\nThe drawback of this method is that if two Views both use a bitmap, the bitmap will be erased from the cache on exit from the first View and cached again on entry to the second View.'),Object(c.b)("p",null,"The Bitmap::cacheRemoveBitmap can be used to selective uncache bitmaps and thus reduce this overhead. The drawback of the cacheRemoveBitmap is that the cache memory will be fragmented."),Object(c.b)("h2",{id:"replace-the-background-bitmap"},"Replace the background Bitmap"),Object(c.b)("p",null,'If your application have a set of minor bitmaps (e.g. icons) and some full screen "background" bitmaps another strategy can be advised:'),Object(c.b)("p",null,"Cache all the small bitmaps prior to entering the first screen. A good place to do this is in the FrontendApplication constructor. Also cache the background bitmap for the first screen:"),Object(c.b)("pre",null,Object(c.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp"}),"FrontendApplication::FrontendApplication(Model& m, FrontendHeap& heap)\n    : touchgfx::MVPApplication(),\n      transitionCallback(),\n      frontendHeap(heap),\n      model(m)\n{\n    //cache some icons\n    Bitmap::cache(BITMAP_ICON10_ID);\n    Bitmap::cache(BITMAP_ICON11_ID);\n    Bitmap::cache(BITMAP_ICON12_ID);\n\n    //cache first background\n    Bitmap::cache(BITMAP_SCREEN1_ID);\n    backgroundBitmapCached = BITMAP_SCREEN1_ID; //remember ID\n}\n")),Object(c.b)("p",null,"In the ",Object(c.b)(p.a,{text:"setupScreen",mdxType:"InlineCode"})," method replace the cached background bitmap with the required bitmap:"),Object(c.b)("pre",null,Object(c.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp"}),"Screen1View::setupScreen()\n{\n    //ensure background is cached\n    Bitmap::cacheReplaceBitmap(backgroundBitmapCached, BITMAP_SCREEN1_ID);\n    backgroundBitmapCached = BITMAP_SCREEN1_ID;\n}\n")),Object(c.b)("pre",null,Object(c.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp"}),"void Screen1View::tearDownScreen()\n{\n    //nothing cache related\n}\n")),Object(c.b)("p",null,"The memory requirement for the cache is the size of the cached bitmaps and one background bitmap. Compared to the previous method the code is simpler to maintain as the views has less code. The performance is better as we move less bitmaps in and out of the cache."),Object(c.b)("p",null,"The cacheReplaceBitmap operation is preferable to the cacheRemoveBitmap method as it does not fragment the memory."),Object(c.b)("h2",{id:"cache-memory-management"},"Cache Memory Management"),Object(c.b)("p",null,"In order to get the full effect of the bitmap caching it is necessary to understand the internal operations of the cache."),Object(c.b)("p",null,'The cache is implemented as a stack. New bitmaps are cached on top of the previously cached bitmaps. Memory used by a bitmap is marked as "free" when the bitmap is removed from the cache. The memory is not immediately useable unless the removed bitmap was on top of the stack.\nIf the bitmap was in "the middle" a compacting operation is performed the next time Bitmap::cache is called to reclaim the memory. This "costly" method can be avoided if you do not call Bitmap::cache with a "hole" in the cache.'),Object(c.b)("p",null,"The drawings below illustrates the principles."),Object(c.b)("p",null,"Caching allocates on top of the previously allocated bitmaps:"),Object(c.b)(o.a,{imageSource:"/img/Development/UIDevelopment/Scenarios/UsingNonMemoryMappedFlashForStoringImages/cache-operations-cache.png",caption:"Allocation sequence of bitmaps in memory",mdxType:"Figure"}),Object(c.b)("p",null,"Removal marks the used memory:"),Object(c.b)(o.a,{imageSource:"/img/Development/UIDevelopment/Scenarios/UsingNonMemoryMappedFlashForStoringImages/cache-operations-uncache.png",caption:"Unused memory in cache after removal of cached bitmap",mdxType:"Figure"}),Object(c.b)("p",null,"Allocating the next bitmap compacts the cache and allocates on the top:"),Object(c.b)(o.a,{imageSource:"/img/Development/UIDevelopment/Scenarios/UsingNonMemoryMappedFlashForStoringImages/cache-operations-compact.png",caption:"cache compaction of unused memory after caching a bitmap",mdxType:"Figure"}),Object(c.b)("p",null,"When you remove the topmost (last allocated) bitmap, the memory is freed immediately along with any free memory just below it:"),Object(c.b)(o.a,{imageSource:"/img/Development/UIDevelopment/Scenarios/UsingNonMemoryMappedFlashForStoringImages/cache-operations-uncache-top.png",caption:"Topmost bitmap cache removal",mdxType:"Figure"}),Object(c.b)("p",null,"The next cache operation will in this case not involve a compact."))}d.isMDXComponent=!0},227:function(e,t,a){"use strict";a.d(t,"a",(function(){return h})),a.d(t,"b",(function(){return d}));var n=a(0),r=a.n(n);function c(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){c(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function p(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},c=Object.keys(e);for(n=0;n<c.length;n++)a=c[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(e);for(n=0;n<c.length;n++)a=c[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=r.a.createContext({}),l=function(e){var t=r.a.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i({},t,{},e)),a},h=function(e){var t=l(e.components);return r.a.createElement(s.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},b=Object(n.forwardRef)((function(e,t){var a=e.components,n=e.mdxType,c=e.originalType,o=e.parentName,s=p(e,["components","mdxType","originalType","parentName"]),h=l(a),m=n,b=h["".concat(o,".").concat(m)]||h[m]||u[m]||c;return a?r.a.createElement(b,i({ref:t},s,{components:a})):r.a.createElement(b,i({ref:t},s))}));function d(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var c=a.length,o=new Array(c);o[0]=b;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i[m]="string"==typeof e?e:n,o[1]=i;for(var s=2;s<c;s++)o[s]=a[s];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,a)}b.displayName="MDXCreateElement"},228:function(e,t,a){"use strict";var n=a(5),r=a(0),c=a.n(r),o=function(e){function t(){return e.apply(this,arguments)||this}return Object(n.a)(t,e),t.prototype.render=function(){var e="highlight highlight-"+this.props.type;return c.a.createElement("div",{class:e},c.a.createElement("div",{class:"highlight-heading"},c.a.createElement("h5",null,c.a.createElement("div",{class:"highlight-icon"},this.props.icon),this.props.header)),c.a.createElement("div",{class:"highlight-content"},this.props.children))},t}(r.Component);t.a=o},229:function(e,t,a){"use strict";var n=a(5),r=a(0),c=a.n(r),o=function(e){function t(){return e.apply(this,arguments)||this}return Object(n.a)(t,e),t.prototype.render=function(){var e=this.props.noShadow||!1,t=this.props.width,a=this.props.height;return e?c.a.createElement("div",{class:"figure noshadow"},c.a.createElement("a",{href:this.props.imageSource,target:"_blank"},c.a.createElement("img",{width:t,height:a,src:this.props.imageSource})),c.a.createElement("p",null,this.props.caption)):c.a.createElement("div",{class:"figure"},c.a.createElement("a",{href:this.props.imageSource,target:"_blank"},c.a.createElement("img",{width:t,height:a,src:this.props.imageSource})),c.a.createElement("p",null,this.props.caption))},t}(r.Component);t.a=o},230:function(e,t,a){"use strict";var n=a(1),r=a(0),c=a.n(r),o=a(34),i=/^\/(?!\/)/;t.a=function(e){var t,a=e.to,p=e.href,s=a||p,l=i.test(s),h=Object(r.useRef)(!1),m="undefined"!=typeof window&&"IntersectionObserver"in window;return Object(r.useEffect)((function(){return!m&&l&&window.docusaurus.prefetch(s),function(){m&&t&&t.disconnect()}}),[s,m,l]),s&&l?c.a.createElement(o.b,Object(n.a)({},e,{onMouseEnter:function(){h.current||(window.docusaurus.preload(s),h.current=!0)},innerRef:function(e){var a,n;m&&e&&l&&(a=e,n=function(){window.docusaurus.prefetch(s)},(t=new window.IntersectionObserver((function(e){e.forEach((function(e){a===e.target&&(e.isIntersecting||e.intersectionRatio>0)&&(t.unobserve(a),t.disconnect(),n())}))}))).observe(a))},to:s})):c.a.createElement("a",Object(n.a)({},e,{href:s}))}},231:function(e,t,a){"use strict";var n=a(5),r=a(0),c=a.n(r),o=a(228),i=c.a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},c.a.createElement("path",{"fill-rule":"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})),p=function(e){function t(){return e.apply(this,arguments)||this}return Object(n.a)(t,e),t.prototype.render=function(){return c.a.createElement(o.a,{color:"var(--highlight-color-further-reading)",header:"Further reading",type:"further-reading",icon:i},this.props.children)},t}(r.Component);t.a=p},232:function(e,t,a){"use strict";var n=a(5),r=a(0),c=a.n(r),o=function(e){function t(){return e.apply(this,arguments)||this}return Object(n.a)(t,e),t.prototype.render=function(){return c.a.createElement("code",null,this.props.text)},t}(r.Component);t.a=o},234:function(e,t,a){"use strict";var n=a(5),r=a(0),c=a.n(r),o=function(e){function t(){return e.apply(this,arguments)||this}return Object(n.a)(t,e),t.prototype.render=function(){return c.a.createElement("div",{class:"code-header"},c.a.createElement("div",null,c.a.createElement("h5",null,this.props.children)))},t}(r.Component);t.a=o},235:function(e,t,a){"use strict";var n=a(5),r=a(0),c=a.n(r),o=a(228),i=c.a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},c.a.createElement("path",{"fill-rule":"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"})),p=function(e){function t(){return e.apply(this,arguments)||this}return Object(n.a)(t,e),t.prototype.render=function(){return c.a.createElement(o.a,{color:"var(--highlight-color-tip)",header:"Tip",type:"tip",icon:i},this.props.children)},t}(r.Component);t.a=p},246:function(e,t,a){"use strict";var n=a(5),r=a(0),c=a.n(r),o=a(228),i=c.a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},c.a.createElement("path",{"fill-rule":"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"})),p=function(e){function t(){return e.apply(this,arguments)||this}return Object(n.a)(t,e),t.prototype.render=function(){return c.a.createElement(o.a,{color:"var(--highlight-color-caution)",header:"Caution",type:"caution",icon:i},this.props.children)},t}(r.Component);t.a=p},248:function(e,t,a){"use strict";var n=a(5),r=a(0),c=a.n(r),o=a(228),i=c.a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},c.a.createElement("path",{"fill-rule":"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})),p=function(e){function t(){return e.apply(this,arguments)||this}return Object(n.a)(t,e),t.prototype.render=function(){return c.a.createElement(o.a,{color:"var(--highlight-color-try)",header:"Things to try",type:"try",icon:i},this.props.children)},t}(r.Component);t.a=p}}]);