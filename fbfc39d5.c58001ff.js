(window.webpackJsonp=window.webpackJsonp||[]).push([[127],{259:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return p})),a.d(t,"metadata",(function(){return m})),a.d(t,"rightToc",(function(){return l})),a.d(t,"default",(function(){return u}));var n=a(1),c=a(9),i=(a(0),a(264)),o=a(265),r=(a(280),a(277)),h=(a(279),a(274),a(278)),s=(a(267),a(273)),p={id:"caching-bitmaps",title:"Caching Bitmaps"},m={id:"development/ui-development/touchgfx-engine-features/caching-bitmaps",title:"Caching Bitmaps",description:"import Figure from '@site/components/Figure';\r",source:"@site/docs\\development\\ui-development\\touchgfx-engine-features\\caching-bitmaps.mdx",permalink:"/docs/development/ui-development/touchgfx-engine-features/caching-bitmaps",sidebar:"docs",previous:{title:"Custom Containers",permalink:"/docs/development/ui-development/touchgfx-engine-features/custom-containers"},next:{title:"Custom Widgets",permalink:"/docs/development/ui-development/touchgfx-engine-features/custom-widgets"}},l=[{value:"Setup the Bitmap Cache",id:"setup-the-bitmap-cache",children:[{value:"Bitmap Cache Configuration",id:"bitmap-cache-configuration",children:[]},{value:"BlockCopy copies data from flash to the cache",id:"blockcopy-copies-data-from-flash-to-the-cache",children:[]}]},{value:"Cache Operations",id:"cache-operations",children:[]},{value:"Cache Strategies",id:"cache-strategies",children:[{value:"Cache Bitmap on a Screen basis",id:"cache-bitmap-on-a-screen-basis",children:[]},{value:"Replace the background Bitmaps in the cache",id:"replace-the-background-bitmaps-in-the-cache",children:[]}]},{value:"Cache Memory Management",id:"cache-memory-management",children:[]}],b={rightToc:l},d="wrapper";function u(e){var t=e.components,a=Object(c.a)(e,["components"]);return Object(i.b)(d,Object(n.a)({},b,a,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"In this section we will discuss the bitmap cache in TouchGFX. The\nbitmap cache is a dedicated RAM buffer where bitmaps can be stored (or\ncached) by the application.\nIf a bitmap is cached, TouchGFX will automatically use the RAM cache\nas pixel source when drawing the bitmap."),Object(i.b)("p",null,"Bitmap caching can be benificial in many cases. Reading data from RAM\nis often faster than reading from flash (especially when using the\nTexturemapper because it uses non-linear memory access), so caching to\nRAM can increase the performance of your UI. Be aware that caching\nfrom internal flash to external RAM can reduce performance.\nCaching to RAM also allows you to use the flash for other purposes\nlike log files while showing your UI, because bitmaps will be read\nfrom RAM (in some cases writing to a flash requires it to be\nnon-memory mapped).  It can also be useful when you need to modify the\npixels of bitmap and therefore need the bitmap to be in modifiable\nmemory."),Object(i.b)("p",null,"For performance reasons, TouchGFX requires all graphics data stored in\nexternal flash to be directly accessible (through a pointer), without\ngoing through a driver layer. This means that TouchGFX cannot render\ndirectly from a non-memory mapped flash (like an SD-card).\nTo overcome this limitation the bitmap cache provides a mechanism for\ncaching some or all of the bitmap data in RAM during power-up.\nBitmap caching is therefore useful when you need to store your bitmaps\non slow external storage like an USB-disk or SD-card."),Object(i.b)("h2",{id:"setup-the-bitmap-cache"},"Setup the Bitmap Cache"),Object(i.b)("p",null,"In order to use the bitmap caching feature, you need to first provide\na bitmap cache configuration to TouchGFX, and secondly (in some cases)\nto provide a hardware specific implementation of the ",Object(i.b)("inlineCode",{parentName:"p"},"BlockCopy")," function for\nreading data from your external storage."),Object(i.b)("h3",{id:"bitmap-cache-configuration"},"Bitmap Cache Configuration"),Object(i.b)("p",null,"The bitmap cache configuration consists of a pointer to a buffer and\nthe size of the buffer. These two values must be provided to TouchGFX\nin the call to touchgfx_generic_init or\nBitmap::registerBitmapDatabase. This call is normally found in the\nBoardConfiguration.cpp file:"),Object(i.b)(s.a,{mdxType:"CodeHeader"},"BoardConfiguration.cpp (extract)"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp"}),"// Place cache start address in SDRAM at address 0xC0008000;\nuint16_t* cacheStartAddr = (uint16_t*)0xC0008000;\nuint32_t cacheSize = 0x300000; //3 MB, as example\nHAL& hal = touchgfx_generic_init<STM32F4HAL>(dma, display, tc, DISPLAY_WIDTH, DISPLAY_HEIGHT, cacheStartAddr, cacheSize);\n")),Object(i.b)("p",null,"In the above example a 3 MB buffer in external memory is passed to\nTouchGFX as bitmap cache. The address is selected by the application\nprogrammer. In the next example we just declare an array and just pass\nthe address and size of the array. The specific location of the array\nwill depend on your linker script. This method is most often used when\ncreating a (small) bitmap cache in internal RAM:"),Object(i.b)(s.a,{mdxType:"CodeHeader"},"BoardConfiguration.cpp (extract)"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp"}),"// Define an array for the bitmap cache\nuint16_t cache[128*1024]; //128 KB cache\nHAL& hal = touchgfx_generic_init<STM32F4HAL>(dma, display, tc, DISPLAY_WIDTH, DISPLAY_HEIGHT, &cache, sizeof(cache));\n")),Object(i.b)(r.a,{mdxType:"Tip"},"If you are using CubeMX, you should enable and configure the bitmap cache in the file TouchGFXConfiguration.cpp."),Object(i.b)("p",null,"If you need to cache all your bitmaps, of course the size of the cache\nmust be large enough to contain all your bitmap data.\nNote: There is a small amount of memory used for bookkeeping (8 bytes\nx number of bitmaps in the application), so you must allocate slightly\nmore memory than actually needed for the raw pixel data. This amount\ndepends on the number of bitmaps in your application, but a few\nkilobytes of additional memory is usually enough."),Object(i.b)("h3",{id:"blockcopy-copies-data-from-flash-to-the-cache"},"BlockCopy copies data from flash to the cache"),Object(i.b)("p",null,"When you cache a bitmap, TouchGFX copies the pixels from the original\nlocation to the bitmap cache using the ",Object(i.b)("inlineCode",{parentName:"p"},"BlockCopy")," function in the\nHAL class."),Object(i.b)("p",null,"If your bitmaps are stored in normal addressable flash (like internal\nflash or a memory mapped external flash like a QSPI-flash), you do not\nneed to do anything. The built-in implementation works fine."),Object(i.b)("p",null,"On the other hand, if your bitmaps are stored in flash that is not\naddressable, e.g. a filesystem or non-memory mapped flash, then the\nstandard copy method is not sufficient and you need to provide an\nupdated version that is able to read from your specific flash storage."),Object(i.b)("p",null,"Read more about this topic ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"/docs/development/ui-development/scenarios/using-non-memory-mapped-flash"}),"Using Non-Memory Mapped flash for storing images"),"\nsection."),Object(i.b)("h2",{id:"cache-operations"},"Cache Operations"),Object(i.b)("p",null,"The bitmap caching operations are all placed in the ",Object(i.b)("inlineCode",{parentName:"p"},"Bitmap")," class:"),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("strong",{parentName:"th"},Object(i.b)("inlineCode",{parentName:"strong"},"Bitmap")," caching method")),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("strong",{parentName:"th"},"Description")))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"bool Bitmap::cache(BitmapId id)")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"This method caches a bitmap. The bitmap is only cached if enough unused memory is available in the cache. Returns true if the bitmap was cached. Caching an already cached bitmap does not do any work.")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"bool Bitmap::cacheReplaceBitmap(BitmapId out, BitmapId in)")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"This method replaces a bitmap (out) in the cache with another bitmap (in). The method will only succeed if the bitmap to be replaced is already cached and if the bitmaps have the same size (in bytes).")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"bool Bitmap::cacheRemoveBitmap(BitmapId id)")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"This method removes a bitmap from the cache. The memory used by the bitmap can be used for caching of another bitmap afterwards.")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"void Bitmap::clearCache()")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"This method removes all the cached bitmaps from the cache.")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"void Bitmap::cacheAll()")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"This method caches all bitmaps. It can not be used if the amount of RAM allocated for the cache (or available) is less than the total size of the bitmaps.")))),Object(i.b)("h2",{id:"cache-strategies"},"Cache Strategies"),Object(i.b)("p",null,"When the amount of RAM that you can allocate for your bitmap cache is\nless than the total size of the bitmaps you can not cache all the\nbitmaps during startup.\nYou can e.g. select to cache only the bitmaps needed for the first\nscreen. When you change between your screens you can remove some or\nall of the cached bitmaps and cache the bitmaps needed for the next\nscreen. This is examplified in the next section."),Object(i.b)("h3",{id:"cache-bitmap-on-a-screen-basis"},"Cache Bitmap on a Screen basis"),Object(i.b)("p",null,"Your application user interface is composed of a set of Views. The\nViews probably all use some bitmaps.  A simple strategy for caching is\nto cache all the bitmaps used by a View in the ",Object(i.b)(h.a,{text:"View::setupScreen",mdxType:"InlineCode"})," method and clear the cache in the"),Object(i.b)(h.a,{text:"View::tearDownScreen",mdxType:"InlineCode"})," method:",Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp"}),"void Screen1View::setupScreen()\n{\n    //ensure background is cached\n    Bitmap::cache(BITMAP_SCREEN2_ID);\n    //cache some icons\n    Bitmap::cache(BITMAP_ICON10_ID);\n    Bitmap::cache(BITMAP_ICON11_ID);\n    Bitmap::cache(BITMAP_ICON12_ID);\n}\n\nvoid Screen1View::tearDownScreen()\n{\n    //Remove all bitmaps from the cache\n    Bitmap::clearCache();\n}\n")),Object(i.b)("p",null,"The memory requirement for the cache is the size of the bitmaps used\nby the screen with the biggest use of bitmaps.\nThe drawback of this method is that if two ",Object(i.b)("inlineCode",{parentName:"p"},"Views")," both use a\nbitmap, the bitmap will be erased from the cache on exit from the\nfirst ",Object(i.b)("inlineCode",{parentName:"p"},"View")," and cached again on entry to the second ",Object(i.b)("inlineCode",{parentName:"p"},"View"),"."),Object(i.b)("p",null,"The Bitmap::cacheRemoveBitmap can be used to selective uncache bitmaps\nand thus reduce this overhead. The drawback of the cacheRemoveBitmap\nis that the cache memory will be fragmented."),Object(i.b)("p",null,"Another general drawback of caching is that when you change your UI\n(e.g. adding a button) you may need to update the caching code to\ninclude the new bitmap."),Object(i.b)("h3",{id:"replace-the-background-bitmaps-in-the-cache"},"Replace the background Bitmaps in the cache"),Object(i.b)("p",null,'If your application have a set of minor bitmaps (e.g. icons) and some\nlarge full screen "background" bitmaps another strategy can be\nadvised:'),Object(i.b)("p",null,"Cache all the small bitmaps prior to entering the first screen. A good\nplace to do this is in the FrontendApplication constructor. Also cache\nthe background bitmap for the first screen:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp"}),"FrontendApplication::FrontendApplication(Model& m, FrontendHeap& heap)\n    : touchgfx::MVPApplication(),\n      transitionCallback(),\n      frontendHeap(heap),\n      model(m)\n{\n    //cache some icons\n    Bitmap::cache(BITMAP_ICON10_ID);\n    Bitmap::cache(BITMAP_ICON11_ID);\n    Bitmap::cache(BITMAP_ICON12_ID);\n\n    //cache first background\n    Bitmap::cache(BITMAP_SCREEN1_ID);\n    backgroundBitmapCached = BITMAP_SCREEN1_ID; //remember ID in a variable\n}\n")),Object(i.b)("p",null,"In the ",Object(i.b)(h.a,{text:"View::setupScreen",mdxType:"InlineCode"})," method replace the\ncached background bitmap with the required bitmap:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp"}),"Screen1View::setupScreen()\n{\n    //ensure background is cached\n    Bitmap::cacheReplaceBitmap(backgroundBitmapCached, BITMAP_SCREEN1_ID);\n    backgroundBitmapCached = BITMAP_SCREEN1_ID; //remember new ID of cached bitmap\n}\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp"}),"void Screen1View::tearDownScreen()\n{\n    //nothing cache related\n}\n")),Object(i.b)("p",null,"The memory requirement for the cache using this strategy is the size\nof the cached bitmaps and one background bitmap. Compared to the\nprevious method the code is simpler to maintain as the views have less\ncode. The performance is better as we move less bitmaps in and out of\nthe cache."),Object(i.b)("p",null,"The cacheReplaceBitmap operation is preferable to the\ncacheRemoveBitmap method as it does not fragment the memory."),Object(i.b)("h2",{id:"cache-memory-management"},"Cache Memory Management"),Object(i.b)("p",null,"In order to get the full effect of the bitmap caching it is necessary to understand the internal operations of the cache."),Object(i.b)("p",null,'The cache is implemented as a stack. New bitmaps are cached after\nthe previously cached bitmaps. Memory used by a bitmap is marked as\n"free" when the bitmap is removed from the cache, but the memory is not\nimmediately useable unless the removed bitmap was on top of the stack.\nIf the bitmap was in "the middle" of the cache a compacting operation\nis performed the next time Bitmap::cache is called to reclaim the\nmemory. This "costly" method can be avoided if you do not call\nBitmap::cache with a "hole" in the cache.'),Object(i.b)("p",null,"The drawings below illustrates the principles:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Caching allocates on top of the previously allocated bitmaps:")),Object(i.b)(o.a,{imageSource:"/img/development/ui-development/touchgfx-engine-features/caching-bitmaps/cache-operations-cache.png",caption:"Allocation sequence of bitmaps in memory",noShadow:"true",width:"340",mdxType:"Figure"}),Object(i.b)("ol",{start:2},Object(i.b)("li",{parentName:"ol"},"Removal marks the memory unused:")),Object(i.b)(o.a,{imageSource:"/img/development/ui-development/touchgfx-engine-features/caching-bitmaps/cache-operations-uncache.png",caption:"Unused memory in cache after removal of cached bitmap",noShadow:"true",width:"340",mdxType:"Figure"}),Object(i.b)("ol",{start:3},Object(i.b)("li",{parentName:"ol"},"Allocating the next bitmap compacts the cache and allocates on the top:")),Object(i.b)(o.a,{imageSource:"/img/development/ui-development/touchgfx-engine-features/caching-bitmaps/cache-operations-compact.png",caption:"The cache reclaims unused memory before caching a bitmap",noShadow:"true",width:"340",mdxType:"Figure"}),Object(i.b)("ol",{start:4},Object(i.b)("li",{parentName:"ol"},"When you remove the topmost (last allocated) bitmap, the memory is freed immediately along with any free memory just below it:")),Object(i.b)(o.a,{imageSource:"/img/development/ui-development/touchgfx-engine-features/caching-bitmaps/cache-operations-uncache-top.png",caption:"Topmost bitmap cache removal",noShadow:"true",width:"700",mdxType:"Figure"}),Object(i.b)("p",null,"The next cache operation will in this case not involve a compact."),Object(i.b)("p",null,"This animation shows the whole sequence for this code:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp"}),"Bitmap::cache(BITMAP_BITMAP1_ID);\nBitmap::cache(BITMAP_BITMAP2_ID);\nBitmap::cache(BITMAP_BITMAP3_ID);\n...\nBitmap::cacheRemoveBitmap(BITMAP_BITMAP2_ID);\n...\nBitmap::cache(BITMAP_BITMAP4_ID);\n...\nBitmap::cacheRemoveBitmap(BITMAP_BITMAP3_ID);\nBitmap::cacheRemoveBitmap(BITMAP_BITMAP4_ID);\n")),Object(i.b)(o.a,{width:"600",imageSource:"/img/development/ui-development/touchgfx-engine-features/caching-bitmaps/cache-bitmap-animation.gif",caption:"Caching and unchaching bitmaps",mdxType:"Figure"}))}u.isMDXComponent=!0},279:function(e,t,a){"use strict";var n=a(5),c=a(0),i=a.n(c),o=a(269),r=i.a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},i.a.createElement("path",{"fill-rule":"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})),h=function(e){function t(){return e.apply(this,arguments)||this}return Object(n.a)(t,e),t.prototype.render=function(){return i.a.createElement(o.a,{color:"var(--highlight-color-try)",header:"Things to try",type:"try",icon:r},this.props.children)},t}(c.Component);t.a=h},280:function(e,t,a){"use strict";var n=a(5),c=a(0),i=a.n(c),o=a(269),r=i.a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},i.a.createElement("path",{"fill-rule":"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"})),h=function(e){function t(){return e.apply(this,arguments)||this}return Object(n.a)(t,e),t.prototype.render=function(){return i.a.createElement(o.a,{color:"var(--highlight-color-caution)",header:"Caution",type:"caution",icon:r},this.props.children)},t}(c.Component);t.a=h}}]);