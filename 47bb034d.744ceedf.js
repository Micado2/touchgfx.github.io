(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{176:function(e,t,r){"use strict";r.r(t),r.d(t,"frontMatter",(function(){return f})),r.d(t,"metadata",(function(){return u})),r.d(t,"rightToc",(function(){return d})),r.d(t,"default",(function(){return b}));var n=r(1),a=r(9),o=(r(0),r(264)),i=r(265),c=r(268),l=r(277),s=(r(279),r(273)),f=(r(274),r(278),r(266),r(270),{id:"scenarios-framebuffer-strategies",title:"Framebuffer Strategies"}),u={id:"development/touchgfx-hal-development/scenarios/scenarios-framebuffer-strategies",title:"Framebuffer Strategies",description:"import Figure from '@site/components/Figure';\r",source:"@site/docs\\development\\touchgfx-hal-development\\scenarios\\scenarios-framebuffer-strategies.mdx",permalink:"/docs/development/touchgfx-hal-development/scenarios/scenarios-framebuffer-strategies",sidebar:"docs",previous:{title:"FMC and SPI",permalink:"/docs/development/touchgfx-hal-development/scenarios/scenarios-fmc"},next:{title:"External events as triggers",permalink:"/docs/development/board-bring-up/example-gpio"}},d=[{value:"Single Frame Buffer",id:"single-frame-buffer",children:[{value:"By Allocation",id:"by-allocation",children:[]},{value:"By Address",id:"by-address",children:[]}]},{value:"Double Frame Buffer",id:"double-frame-buffer",children:[{value:"By Address",id:"by-address-1",children:[]},{value:"By Allocation",id:"by-allocation-1",children:[]}]},{value:"Partial Frame Buffer",id:"partial-frame-buffer",children:[]}],h={rightToc:d},p="wrapper";function b(e){var t=e.components,r=Object(a.a)(e,["components"]);return Object(o.b)(p,Object(n.a)({},h,r,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"This section shows how to configure the ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/docs/development/touchgfx-hal-development/touchgfx-generator"}),"TouchGFX Generator")," to generate a TouchGFX HAL that uses one of the following Frame Buffer strategies:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Single"),Object(o.b)("li",{parentName:"ul"},"Double"),Object(o.b)("li",{parentName:"ul"},"Partial")),Object(o.b)("h2",{id:"single-frame-buffer"},"Single Frame Buffer"),Object(o.b)("p",null,"Choosing ",Object(o.b)("em",{parentName:"p"},"Single Buffer")," as the buffering strategy developers are able to let the compiler allocate memory for the framebuffer in internal RAM but can also choose a specific location for the buffer."),Object(o.b)("h3",{id:"by-allocation"},"By Allocation"),Object(o.b)("p",null,"When choosing ",Object(o.b)("em",{parentName:"p"},"By Allocation")," TouchGFX Generator will allocate an array based on the dimensions and bitdepth of the application."),Object(o.b)(i.a,{noShadow:!0,imageSource:"/img/development/touchgfx-hal-development/scenarios/framebuffer-single-alloc.png",width:"400",caption:"Single framebuffer, by allocation",mdxType:"Figure"}),Object(o.b)("p",null,"Code is generated to configure the HAL to use this array as the framebuffer. "),Object(o.b)(s.a,{mdxType:"CodeHeader"},"TouchGFXGeneratedHAL.cpp"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp",metastring:"{1-6,12}","{1-6,12}":!0}),'namespace {\n    // Use the section "TouchGFX_Framebuffer" in the linker script\n    // to specify the placement of the buffer\n    LOCATION_PRAGMA("TouchGFX_Framebuffer")\n    uint32_t frameBuf[(480 * 272 * 2 + 3) / 4] LOCATION_ATTRIBUTE("TouchGFX_Framebuffer");\n}\n\nvoid TouchGFXGeneratedHAL::initialize()\n{\n    HAL::initialize();\n\n    setFrameBufferStartAddresses((void*)frameBuf, (void*)0, (void*)0);\n}\n')),Object(o.b)("h3",{id:"by-address"},"By Address"),Object(o.b)("p",null,"When choosing ",Object(o.b)("em",{parentName:"p"},"By Address")," for the location of the framebuffer TouchGFX Generator will use the  specified Start Addresses during HAL initialization."),Object(o.b)(i.a,{noShadow:!0,imageSource:"/img/development/touchgfx-hal-development/scenarios/framebuffer-single-addr.png",width:"400",caption:"Single framebuffer, by address",mdxType:"Figure"}),Object(o.b)(s.a,{mdxType:"CodeHeader"},"TouchGFXGeneratedHAL.cpp"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp",metastring:"{5}","{5}":!0}),"void TouchGFXGeneratedHAL::initialize()\n{\n    HAL::initialize();\n\n    setFrameBufferStartAddresses((void*)0xC0000000, (void*)0, (void*)0);\n}\n")),Object(o.b)("h2",{id:"double-frame-buffer"},"Double Frame Buffer"),Object(o.b)("p",null,"In a double frame buffer configuration, code to swap farmebuffers will be generated in the HAL by TouchGFX Generator depending on the selected Framebuffer strategy and display interface. This memory interface to frame buffer location is used by the TouchGFX Engine during the main event loop."),Object(o.b)("h3",{id:"by-address-1"},"By Address"),Object(o.b)("p",null,"When choosing ",Object(o.b)("em",{parentName:"p"},"By Address")," TouchGFX Generator will use the two specified Start Addresses during HAL initialization."),Object(o.b)(i.a,{noShadow:!0,imageSource:"/img/development/touchgfx-hal-development/scenarios/framebuffer-double.png",width:"400",caption:"Double framebuffer, by address",mdxType:"Figure"}),Object(o.b)(s.a,{mdxType:"CodeHeader"},"TouchGFXGeneratedHAL.cpp"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp",metastring:"{5}","{5}":!0}),"void TouchGFXGeneratedHAL::initialize()\n{\n    HAL::initialize();\n\n    setFrameBufferStartAddresses((void*)0xC0000000, (void*)0xC003FC00, (void*)0);\n}\n")),Object(o.b)(l.a,{mdxType:"Tip"},"When using Parallel RGB (LTDC) as display interface, the start address will be inherited from the LTDC Layer settings."),Object(o.b)("h3",{id:"by-allocation-1"},"By Allocation"),Object(o.b)("p",null,"When choosing ",Object(o.b)("em",{parentName:"p"},"By Allocation")," TouchGFX Generator will allocate an array based on the dimensions and bitdepth of the application, exactly as with a Single Frame Buffer, only twice the size."),Object(o.b)(i.a,{noShadow:!0,imageSource:"/img/development/touchgfx-hal-development/scenarios/framebuffer-double-alloc.png",width:"400",caption:"Single framebuffer, by allocation",mdxType:"Figure"}),Object(o.b)(s.a,{mdxType:"CodeHeader"},"TouchGFXGeneratedHAL.cpp"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp",metastring:"{1-5,11}","{1-5,11}":!0}),'namespace {\n    // Use the section "TouchGFX_Framebuffer" in the linker to specify the placement of the buffer\n    LOCATION_PRAGMA("TouchGFX_Framebuffer")\n    uint32_t frameBuf[(480 * 272 * 2 + 3) / 4 * 2] LOCATION_ATTRIBUTE("TouchGFX_Framebuffer");\n}\n\nvoid TouchGFXGeneratedHAL::initialize()\n{\n    HAL::initialize();\n\n    setFrameBufferStartAddresses((void*)frameBuf, (void*)(frameBuf + sizeof(frameBuf)/(sizeof(uint32_t)*2)), (void*)0);\n}\n')),Object(o.b)("h2",{id:"partial-frame-buffer"},"Partial Frame Buffer"),Object(o.b)("p",null,"Selecting the ",Object(o.b)("em",{parentName:"p"},"Partial Buffer")," strategy allows developers to choose a number of blocks and a size for each of these to be used as frame buffers. This strategy uses what TouchGFX calls a ",Object(o.b)("em",{parentName:"p"},"Frame Buffer Allocator")," and is different from supplying either a pointer to external memory where the frame buffer is located, or allocating a fixed sized array in internal memory."),Object(o.b)("p",null,"See the article on ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/docs/basic-concepts/framebuffer"}),"Framebuffer")," for a general overview of the concept of frame buffers."),Object(o.b)(l.a,{mdxType:"Tip"},'Usually, STM32G0 does not have enough internal RAM to fit framebuffer. "Partial Buffer" would be a perfect match for a low cost solution using this MCU.'),Object(o.b)(i.a,{noShadow:!0,imageSource:"/img/development/touchgfx-hal-development/scenarios/generator-partial-fb.png",width:"400",caption:"Partial framebuffer",mdxType:"Figure"}),Object(o.b)("p",null,"Since a partial buffering strategy is typically only used with low cost MCU with no TFT controller and little internal RAM the Partial Buffer Strategy expects the developer to implement the transfer of the contents of the framebuffer to the display. See ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/docs/development/touchgfx-hal-development/scenarios/scenarios-fmc"}),"FMC/SPI Scenario")," for how to transmit pixels to e.g. a serial display on MCUs with no TFT Controller."),Object(o.b)("p",null,"In order to synchronize with TouchGFX when using the Partial Framebuffer strategy developers are required to provide implementations for the following two functions. The code displayed below is generated by CubeMX inside ",Object(o.b)("inlineCode",{parentName:"p"},"TouchGFX/target/generated/TouchGFXGeneratedHAL.cpp")," and defines the interface from developer to the TouchGFX Engine."),Object(o.b)(s.a,{mdxType:"CodeHeader"},"TouchGFXGeneratedHAL.cpp"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp"}),'/* ******************************************************\n* Functions required by Partial Frame Buffer Strategy\n* ******************************************************\n*\n*  *  uint8_t isTransmittingData() must return whether or not data is currently being transmitted, over e.g. SPI.\n*  *  void transmitFrameBufferBlock(uint8_t* pixels, uint16_t x, uint16_t y, uint16_t w, uint16_t h) will be called\n*       when the framework wants to send a block. The user must then transfer\n*       the data represented by the arguments.\n*\n*  A user must call touchgfx::startNewTransfer(); once transmitFrameBufferBlock() has succesfully sent a block.\n*  E.g. if using DMA to transfer the block, this could be called in the "Transfer Completed" interrupt handler.\n*\n*/\nextern "C" void transmitFrameBufferBlock(uint8_t* pixels, uint16_t x, uint16_t y, uint16_t w, uint16_t h);\nextern "C" uint8_t isTransmittingData();\n')),Object(o.b)("p",null,"The following function is also generated by CubeMX inside the read-only ",Object(o.b)("inlineCode",{parentName:"p"},"TouchGFXGeneratedHAL")," class inside ",Object(o.b)("inlineCode",{parentName:"p"},"TouchGFX/target/generated/TouchGFXGeneratedHAL.cpp"),". "),Object(o.b)(c.a,{mdxType:"Note"},"This flushFrameBuffer() function is generally used for MCUs with no TFT Controller. In the case of Partial Frame Buffers the TouchGFX Generator can generate a definition for this method specifically for that frame buffer strategy."),Object(o.b)(s.a,{mdxType:"CodeHeader"},"TouchGFXGeneratedHAL.cpp"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp",metastring:"{12,16}","{12,16}":!0}),"void TouchGFXGeneratedHAL::flushFrameBuffer(const touchgfx::Rect& rect)\n{\n    HAL::flushFrameBuffer(rect);\n\n    // Once flushFrameBuffer() is called by the framework a block is already for transfer\n    // Mark it ready for transfer and transmit it if user defined method \n    // isTransmittingData() does not return false\n    \n    // If data is not being transmitted, transfer the data with user defined method\n    // transmitFrameBufferBlock().\n    frameBufferAllocator->markBlockReadyForTransfer();\n    if (!isTransmittingData())\n    {\n        touchgfx::Rect r;\n        const uint8_t* pixels = frameBufferAllocator->getBlockForTransfer(r);\n        transmitFrameBufferBlock((uint8_t*)pixels, r.x, r.y, r.width, r.height);\n    }\n}\n")))}b.isMDXComponent=!0},266:function(e,t,r){"use strict";var n=r(5),a=r(0),o=r.n(a),i=function(e){function t(){return e.apply(this,arguments)||this}return Object(n.a)(t,e),t.prototype.render=function(){return o.a.createElement("i",null,this.props.text)},t}(a.Component);t.a=i},268:function(e,t,r){"use strict";var n=r(5),a=r(0),o=r.n(a),i=r(269),c=o.a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},o.a.createElement("path",{"fill-rule":"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})),l=function(e){function t(){return e.apply(this,arguments)||this}return Object(n.a)(t,e),t.prototype.render=function(){return o.a.createElement(i.a,{color:"var(--highlight-color-note)",header:"Note",type:"note",icon:c},this.props.children)},t}(a.Component);t.a=l},270:function(e,t,r){"use strict";r(271);var n=r(5),a=r(0),o=r.n(a),i=r(267),c=function(e){function t(){return e.apply(this,arguments)||this}return Object(n.a)(t,e),t.prototype.render=function(){var e="/api/"+this.props.link;return o.a.createElement(i.a,{to:e,target:"_blank"},this.props.children)},t}(a.Component);t.a=c},271:function(e,t,r){"use strict";r(272)("link",(function(e){return function(t){return e(this,"a","href",t)}}))},272:function(e,t,r){var n=r(17),a=r(18),o=r(23),i=/"/g,c=function(e,t,r,n){var a=String(o(e)),c="<"+t;return""!==r&&(c+=" "+r+'="'+String(n).replace(i,"&quot;")+'"'),c+">"+a+"</"+t+">"};e.exports=function(e,t){var r={};r[e]=t(c),n(n.P+n.F*a((function(){var t=""[e]('"');return t!==t.toLowerCase()||t.split('"').length>3})),"String",r)}},279:function(e,t,r){"use strict";var n=r(5),a=r(0),o=r.n(a),i=r(269),c=o.a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},o.a.createElement("path",{"fill-rule":"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})),l=function(e){function t(){return e.apply(this,arguments)||this}return Object(n.a)(t,e),t.prototype.render=function(){return o.a.createElement(i.a,{color:"var(--highlight-color-try)",header:"Things to try",type:"try",icon:c},this.props.children)},t}(a.Component);t.a=l}}]);